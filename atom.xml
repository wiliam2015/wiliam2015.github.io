<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>william&#39;s Blog</title>
  
  <subtitle>学习本无底，前进莫徬徨。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wiliam.me/"/>
  <updated>2022-02-03T12:48:45.464Z</updated>
  <id>http://wiliam.me/</id>
  
  <author>
    <name>william</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java线程状态</title>
    <link href="http://wiliam.me/2020/05/05/javaThreadState.html"/>
    <id>http://wiliam.me/2020/05/05/javaThreadState.html</id>
    <published>2020-05-05T07:47:44.000Z</published>
    <updated>2022-02-03T12:48:45.464Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://imgcdn.yalongkeji.com/blog/20200505174502.png" alt="image-20200505174459849"></p><blockquote><p>Java线程状态</p></blockquote><a id="more"></a><h1 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h1><p>java线程一共有6种状态</p><ul><li><strong>New（新建）</strong></li><li><strong>Runnable（可运行）</strong></li><li><strong>Blocked（被阻塞）</strong></li><li><strong>Waiting（等待）</strong></li><li><strong>Timed waiting（计时等待）</strong></li><li><strong>Terminated（终止）</strong></li></ul><p>转换关系图如下</p><p><img src="http://imgcdn.yalongkeji.com/blog/20200505155259.png" alt="image-20200505155257484"></p><p>说明如下：</p><ol><li><strong>New</strong>：线程创建后但还没开始时的状态就是新建，即<code>new Thread()</code>后线程的状态就是新建，但还没调用start方法。</li><li><strong>Runnable</strong>：线程一旦调用<code>start()</code>方法，无论是否运行，状态都为Runable，但Runnable是从JVM视图看是处于执行状态，但实际上操作系统可能在等待一些资源，如此时处理器在干其他的，此时Runnable可以分成两个子状态<code>Ready</code>和<code>Running</code>，所以通过上图当线程被调度器选中执行实际才处于Running状态。所以显示Runable状态指示表示线程可以运行，不表示线程当下一定在运行，线程是否运行由虚拟机所在操作系统调度决定。</li><li><strong>Timed waiting</strong>:和wait一样，不过会在传入的时间之后或收到其他线程的通知都会恢复到可运行的状态。</li><li><strong>Waiting</strong>：当调用下面没有超时时间的方法是线程会转移到Waiting状态<ul><li><code>Object.wait()</code></li><li><code>Thread.join()</code></li><li><code>LockSupport.park()</code></li></ul></li><li><strong>Blocked</strong>：线程试图获取一个内部对象的<code>Monitor</code>（进入<code>synchronized</code>方法或<code>synchronized</code>块）但是其他线程已经抢先获取，那此线程被阻塞，直到其他线程释放<code>Monitor</code>并且线程调度器允许当前线程获取到<code>Monitor</code>，此线程就恢复到可运行状态。</li><li><strong>Terminated</strong>：线程执行完毕正常结束或执行过程中因未捕获异常意外终止都会是线程进入被终止状态。</li></ol><h2 id="验证DEMO"><a href="#验证DEMO" class="headerlink" title="验证DEMO"></a>验证DEMO</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">                    o.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread syncThread = <span class="keyword">new</span> SyncThread();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"调用new方法后 my thread state:"</span>+t.getState());</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">"调用start方法后 my thread state:"</span>+t.getState());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        syncThread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"调用sleep方法后 my thread state:"</span>+t.getState());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">"进入同步代码块 sync thread state:"</span>+syncThread.getState());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">        System.out.println(<span class="string">"调用wait方法后 my thread state:"</span>+t.getState());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            o.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"调用notify方法后 my thread state:"</span>+t.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">调用new方法后 my thread <span class="keyword">state</span>:NEW</span><br><span class="line">调用start方法后 my thread <span class="keyword">state</span>:RUNNABLE</span><br><span class="line">调用sleep方法后 my thread <span class="keyword">state</span>:TIMED_WAITING</span><br><span class="line">进入同步代码块 sync thread <span class="keyword">state</span>:BLOCKED</span><br><span class="line">调用wait方法后 my thread <span class="keyword">state</span>:WAITING</span><br><span class="line">调用notify方法后 my thread <span class="keyword">state</span>:TERMINATED</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://www.uml-diagrams.org/java-thread-uml-state-machine-diagram-example.html" target="_blank" rel="noopener">https://www.uml-diagrams.org/java-thread-uml-state-machine-diagram-example.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://imgcdn.yalongkeji.com/blog/20200505174502.png&quot; alt=&quot;image-20200505174459849&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Java线程状态&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://wiliam.me/categories/Java/"/>
    
      <category term="java" scheme="http://wiliam.me/categories/Java/java/"/>
    
      <category term="Thread" scheme="http://wiliam.me/categories/Java/java/Thread/"/>
    
    
      <category term="java" scheme="http://wiliam.me/tags/java/"/>
    
      <category term="Thread" scheme="http://wiliam.me/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码编译</title>
    <link href="http://wiliam.me/2020/05/04/springSourceBuild.html"/>
    <id>http://wiliam.me/2020/05/04/springSourceBuild.html</id>
    <published>2020-05-04T04:47:32.000Z</published>
    <updated>2022-02-03T12:48:45.461Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://imgcdn.yalongkeji.com/blog/20200504153807.png" alt="image-20200504153803863"></p><blockquote><p>Spring源码编译</p></blockquote><a id="more"></a><h1 id="Spring源码编译及导入IDEA"><a href="#Spring源码编译及导入IDEA" class="headerlink" title="Spring源码编译及导入IDEA"></a>Spring源码编译及导入IDEA</h1><blockquote><p>前几天同事分享了下Spring源码编译，自己之前也下载了spring源码一直没编译过，正好借此机会自己编译下，本文记录了编译过程，和大家分享。</p></blockquote><h2 id="1-编译之前准备"><a href="#1-编译之前准备" class="headerlink" title="1.编译之前准备"></a>1.编译之前准备</h2><p>网上也找了一些文章，有的用命令行直接编译的，有的是直接导入idea编译的。这里我采用的是第一个。</p><p>相关依赖说明如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java:<span class="number">1.8</span><span class="number">.0</span>_77</span><br><span class="line">Gradle:<span class="number">5.6</span><span class="number">.4</span>(Spring会自动下载，不用预先配置)</span><br><span class="line">Spring分支:<span class="number">5.2</span>.x</span><br></pre></td></tr></table></figure><h3 id="1-1源码下载"><a href="#1-1源码下载" class="headerlink" title="1.1源码下载"></a>1.1源码下载</h3><p>Spring源码下载：<a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework</a></p><blockquote><p>这里有一点需要说明的是5.2.x版本编译不需要在下载Gradle了，编译的时候Spring会直接下载Gradle</p></blockquote><p>源码git clone下来之后，将分支由master切换为5.2.x</p><h3 id="1-2修改仓库地址"><a href="#1-2修改仓库地址" class="headerlink" title="1.2修改仓库地址"></a>1.2修改仓库地址</h3><p>由于spring使用的是maven中央仓库，但中央仓库在国内网络不太稳定，这里配置仓库地址使用阿里云的，修改Spring目录下的<code>build.gradle</code>文件，找到如下位置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">mavenCentral()</span><br><span class="line">maven &#123; url "https://repo.spring.io/libs-spring-framework-build" &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加如下仓库镜像，最后修改结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">maven &#123; name "Alibaba" ; url "https://maven.aliyun.com/repository/public" &#125;</span><br><span class="line">maven &#123; name "Bstek" ; url "https://nexus.bsdn.org/content/groups/public" &#125;</span><br><span class="line">mavenCentral()</span><br><span class="line">maven &#123; url "https://repo.spring.io/libs-spring-framework-build" &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3修改Gradle仓库地址信息"><a href="#1-3修改Gradle仓库地址信息" class="headerlink" title="1.3修改Gradle仓库地址信息"></a>1.3修改Gradle仓库地址信息</h3><ul><li>避免下载的依赖包都放在C盘，占用C盘空间，所以需要修改Gradle仓库位置，将仓库位置和maven本地仓库配置一样即可</li><li>新增环境变量<code>GRADLE_USER_HOME</code>值为<code>D:\maven_repository</code></li></ul><h2 id="2开始编译"><a href="#2开始编译" class="headerlink" title="2开始编译"></a>2开始编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> spring源码目录</span><br><span class="line">gradlew.bat build</span><br></pre></td></tr></table></figure><p>等待编译完成吧,成功截图如下</p><p><img src="http://imgcdn.yalongkeji.com/blog/20200504144159.png" alt="成功截图"></p><p>不编译成功的原因基本上就是网络的原因，所以一定要配置好国内的镜像哦</p><h2 id="3导入IDEA"><a href="#3导入IDEA" class="headerlink" title="3导入IDEA"></a>3导入IDEA</h2><p>我使用的是IDEA社区版，导入方法如下</p><ol><li><p>进入到Spring工作目录</p></li><li><p>使用命令<code>gradlew.bat :spring-oxm:compileTestJava</code>提前预编译好<code>spring-oxm</code></p></li><li><p>打开idea依次选择(File -&gt; New -&gt; Project from Existing Sources)选择spring源码根目录下的<code>build.gradle</code></p><p><img src="http://imgcdn.yalongkeji.com/blog/20200504152706.png" alt="image-20200504152639801"></p><p><img src="http://imgcdn.yalongkeji.com/blog/20200504154714.png" alt="image-20200504152943927"></p></li><li><p>最后等待编译成功吧</p><p><img src="http://imgcdn.yalongkeji.com/blog/20200504153616.png" alt="image-20200504153613707"></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://imgcdn.yalongkeji.com/blog/20200504153807.png&quot; alt=&quot;image-20200504153803863&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring源码编译&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://wiliam.me/categories/Spring/"/>
    
      <category term="SpringFrameWork" scheme="http://wiliam.me/categories/Spring/SpringFrameWork/"/>
    
    
      <category term="Spring" scheme="http://wiliam.me/tags/Spring/"/>
    
      <category term="SpringFrameWork" scheme="http://wiliam.me/tags/SpringFrameWork/"/>
    
  </entry>
  
  <entry>
    <title>理查德福曼学习法</title>
    <link href="http://wiliam.me/2019/08/08/startMethod.html"/>
    <id>http://wiliam.me/2019/08/08/startMethod.html</id>
    <published>2019-08-08T13:05:03.000Z</published>
    <updated>2022-02-03T12:48:45.468Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://imgcdn.yalongkeji.com/blog/20190809085942.png"></p><blockquote><p>被世界公认的效率最高学习法</p></blockquote><a id="more"></a><h1 id="理查德福曼学习法"><a href="#理查德福曼学习法" class="headerlink" title="理查德福曼学习法"></a>理查德福曼学习法</h1><ol><li>选择一个你要学习的内容</li><li>想象如果你要将这些内容教授给一名新人该如何讲解</li><li>如果过程出了问题重新回顾这个内容</li><li>简化让你的讲解越来越简单易懂</li></ol><p>福曼学习法，好好学习，天天向上。</p><p>相关阅读：<a href="https://blog.csdn.net/liwei16611/article/details/89816693" target="_blank" rel="noopener">https://blog.csdn.net/liwei16611/article/details/89816693</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://imgcdn.yalongkeji.com/blog/20190809085942.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;被世界公认的效率最高学习法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习法" scheme="http://wiliam.me/categories/%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    
    
      <category term="学习法" scheme="http://wiliam.me/tags/%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>node管理多个版本与源</title>
    <link href="http://wiliam.me/2019/07/23/node-version.html"/>
    <id>http://wiliam.me/2019/07/23/node-version.html</id>
    <published>2019-07-23T12:55:16.000Z</published>
    <updated>2022-02-03T12:48:45.465Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="http://imgcdn.yalongkeji.com/blog/20190723163039.jpg"></p><blockquote><p>快速切换node版本与node源方法</p></blockquote><a id="more"></a><h1 id="node管理多个版本"><a href="#node管理多个版本" class="headerlink" title="node管理多个版本"></a>node管理多个版本</h1><p>使用：nvm(node版本管理)</p><p>nvm就是nodejs version manage 叫做nodejs 版本管理，而nodejs有很多版本，场景如下:</p><p>　　  1、而你手上开发的有多个项目又分别是不同的nodejs版本，咱们就可以用nvm轻松切换！</p><p>　　  2、假设你正在开发的项目开始使用的nodejs版本是8.0，而现在因为某些原因，你需要升级 或者 降级 nodejs 版本，也可以使用 nvm 轻松切换　　  </p><p>windows安装方法：<a href="https://cloud.tencent.com/developer/news/64123" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/64123</a></p><p>linux安装方法：<a href="https://yq.aliyun.com/articles/688562" target="_blank" rel="noopener">https://yq.aliyun.com/articles/688562</a></p><h1 id="node管理多个源"><a href="#node管理多个源" class="headerlink" title="node管理多个源"></a>node管理多个源</h1><p>使用：nrm —— 快速切换 NPM 源 （附带测速功能）</p><h2 id="安装nrm"><a href="#安装nrm" class="headerlink" title="安装nrm"></a>安装nrm</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nrm</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="列出可选的源"><a href="#列出可选的源" class="headerlink" title="列出可选的源"></a>列出可选的源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nrm ls                                                                                                                                    </span><br><span class="line"></span><br><span class="line">* npm ---- https://registry.npmjs.org/</span><br><span class="line">  cnpm --- http://r.cnpmjs.org/</span><br><span class="line">  taobao - http://registry.npm.taobao.org/</span><br><span class="line">  eu ----- http://registry.npmjs.eu/</span><br><span class="line">  au ----- http://registry.npmjs.org.au/</span><br><span class="line">  sl ----- http://npm.strongloop.com/</span><br><span class="line">  nj ----- https://registry.nodejitsu.com/</span><br></pre></td></tr></table></figure><p>带 <code>*</code> 的是当前使用的源，上面的输出表明当前源是官方源。</p><h2 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h2><p>切换到taobao</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nrm use taobao                                                                                                                             </span><br><span class="line"></span><br><span class="line">   Registry has been <span class="built_in">set</span> to: http://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><h2 id="增加源"><a href="#增加源" class="headerlink" title="增加源"></a>增加源</h2><p>你可以增加定制的源，特别适用于添加企业内部的私有源。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm <span class="built_in">add</span>  <span class="symbol">&lt;registry&gt;</span> <span class="symbol">&lt;url&gt;</span> [home]</span><br></pre></td></tr></table></figure><h2 id="删除源"><a href="#删除源" class="headerlink" title="删除源"></a>删除源</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm del <span class="tag">&lt;<span class="name">registry</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试速度"><a href="#测试速度" class="headerlink" title="测试速度"></a>测试速度</h3><p>你还可以通过 <code>nrm test</code> 测试相应源的响应时间。</p><p>例如，测试官方源的响应时间：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nrm test <span class="built_in">npm</span>                                                                                                                               </span><br><span class="line"></span><br><span class="line">  <span class="built_in">npm</span> ---- <span class="number">1328</span>ms</span><br></pre></td></tr></table></figure><p>测试所有源的响应时间：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> nrm test                                                                                                                                   </span><br><span class="line"></span><br><span class="line">  npm ---- <span class="number">891</span>ms</span><br><span class="line">  cnpm --- <span class="number">1213</span>ms</span><br><span class="line">* taobao - <span class="number">460</span>ms</span><br><span class="line">  eu ----- <span class="number">3859</span>ms</span><br><span class="line">  au ----- <span class="number">1073</span>ms</span><br><span class="line">  sl ----- <span class="number">4150</span>ms</span><br><span class="line">  nj ----- <span class="number">8008</span>ms</span><br></pre></td></tr></table></figure><p>注意，为了取得较准确的结果，可以考虑多次测试取平均值。</p><h2 id="许可"><a href="#许可" class="headerlink" title="许可"></a>许可</h2><p>nrm 为开源软件，使用 MIT 许可。</p><h2 id="项目主页"><a href="#项目主页" class="headerlink" title="项目主页"></a>项目主页</h2><p><a href="https://github.com/Pana/nrm" target="_blank" rel="noopener">github.com/Pana/nrm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;img src=&quot;http://imgcdn.yalongkeji.com/blog/20190723163039.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;快速切换node版本与node源方法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="node" scheme="http://wiliam.me/categories/node/"/>
    
    
      <category term="node" scheme="http://wiliam.me/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>java死锁条件</title>
    <link href="http://wiliam.me/2019/07/02/java-deadlock.html"/>
    <id>http://wiliam.me/2019/07/02/java-deadlock.html</id>
    <published>2019-07-02T13:55:16.000Z</published>
    <updated>2022-02-03T12:48:45.460Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://imgcdn.yalongkeji.com/blog/20190723164843.png" style="width:300px;height:300px"></p><blockquote><p>并发编程时有可能会遇到死锁的情况，但会在什么情况下发生死锁呢。Coffman已经帮我们总结好了。</p></blockquote><a id="more"></a><h1 id="java线程死锁条件"><a href="#java线程死锁条件" class="headerlink" title="java线程死锁条件"></a>java线程死锁条件</h1><p>满足下面4个条件就会死锁，具体如下：</p><ol><li>互斥，共享资源 X 和 Y 只能被一个线程占用；</li><li>占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</li><li>不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</li><li>循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等<br>待。</li></ol><p>所以解决方法就是破坏上面一个条件就可以了，死锁就解决了。</p><p>其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥。不过其他三个条件都是有<br>办法破坏掉的，到底如何做呢？</p><ol><li>对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</li><li>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可<br>以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li><li>对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性<br>顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不<br>存在循环了。</li></ol><h1 id="DEMO示例"><a href="#DEMO示例" class="headerlink" title="DEMO示例"></a>DEMO示例</h1><p><a href="https://github.com/wiliam2015/javaconcurrent/blob/master/src/main/java/me/wiliam/deadlock/DeadLockDemo.java" target="_blank" rel="noopener">示例代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://imgcdn.yalongkeji.com/blog/20190723164843.png&quot; style=&quot;width:300px;height:300px&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;并发编程时有可能会遇到死锁的情况，但会在什么情况下发生死锁呢。Coffman已经帮我们总结好了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://wiliam.me/categories/java/"/>
    
      <category term="deadlock" scheme="http://wiliam.me/categories/java/deadlock/"/>
    
    
      <category term="java" scheme="http://wiliam.me/tags/java/"/>
    
      <category term="deadlock" scheme="http://wiliam.me/tags/deadlock/"/>
    
  </entry>
  
  <entry>
    <title>WIN10安装linux子系统</title>
    <link href="http://wiliam.me/2019/06/20/win10linux.html"/>
    <id>http://wiliam.me/2019/06/20/win10linux.html</id>
    <published>2019-06-20T02:05:03.000Z</published>
    <updated>2022-02-03T12:48:45.463Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://imgcdn.yalongkeji.com/blog/20190723165506.jpg"></p><blockquote><p>win10有许多新特性，其中之一就是可以安装linux子系统，这对于想要学习linux的同学不得不说是个福音，不用再装虚拟机等一系列东西了，网上搜了一些教程跟着教程安装了下，不得不说确实很好用</p></blockquote><a id="more"></a><h1 id="WIN10安装linux子系统"><a href="#WIN10安装linux子系统" class="headerlink" title="WIN10安装linux子系统"></a>WIN10安装linux子系统</h1><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>这里就不自己写了，下面是网上相关的好文章教程链接，大家自己可以参考下</p><p><a href="https://www.jianshu.com/p/bc38ed12da1d" target="_blank" rel="noopener">https://www.jianshu.com/p/bc38ed12da1d</a></p><p><a href="https://jingyan.baidu.com/article/c85b7a64a56c7f003aac954f.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/c85b7a64a56c7f003aac954f.html</a></p><h2 id="本地位置"><a href="#本地位置" class="headerlink" title="本地位置"></a>本地位置</h2><p>安装完成后再本地的存储位置</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\用</span>户名<span class="symbol">\A</span>ppData<span class="symbol">\L</span>ocal<span class="symbol">\P</span>ackages<span class="symbol">\C</span>anonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc<span class="symbol">\L</span>ocalState<span class="symbol">\r</span>ootfs</span><br></pre></td></tr></table></figure><h2 id="进入方法"><a href="#进入方法" class="headerlink" title="进入方法"></a>进入方法</h2><p>进入命令行后输入<code>bash</code>或者输入<code>ubuntu</code>进入linux子系统，这时你可以尽情遨游在linux世界了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://imgcdn.yalongkeji.com/blog/20190723165506.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;win10有许多新特性，其中之一就是可以安装linux子系统，这对于想要学习linux的同学不得不说是个福音，不用再装虚拟机等一系列东西了，网上搜了一些教程跟着教程安装了下，不得不说确实很好用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="win10" scheme="http://wiliam.me/categories/win10/"/>
    
      <category term="linux" scheme="http://wiliam.me/categories/win10/linux/"/>
    
    
      <category term="win10" scheme="http://wiliam.me/tags/win10/"/>
    
      <category term="linux" scheme="http://wiliam.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>自动构建发布</title>
    <link href="http://wiliam.me/2018/10/19/20181019162000.html"/>
    <id>http://wiliam.me/2018/10/19/20181019162000.html</id>
    <published>2018-10-19T08:20:00.000Z</published>
    <updated>2022-02-03T12:48:45.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文章使用Daocloud自动构建发布。</p></blockquote><a id="more"></a><h1 id="自动构建发布"><a href="#自动构建发布" class="headerlink" title="自动构建发布"></a>自动构建发布</h1><p>由于换工作换了电脑，博客一直没有更新，因为要写博客需要把hexo的一堆东西下载到自己的电脑上，工作电脑有一份，家里电脑有一份，太费劲了，而且每次都需要自己更新，所以就想到了能否自动构建发布了，我只提交文章到git上就可以了，之前看我同学的博客有用daocloud发布的，自己借鉴和研究了下，之前工作忙也没仔细研究，现在总算有点时间，所以抽时间研究了下，部署成功了，以后写博客就方便了，后续有时间会把自己此次成功自动构建发布总结下，写个文章发出来，共大家学习参考。</p><blockquote><p>想了解更多技术文章信息，请继续关注<a href="http://wiliam.me">wiliam.s Blog</a>，谢谢，欢迎来访！</p></blockquote><hr><p>参考资料<br><a href="https://www.jianshu.com/p/f3fcecfc0be5" target="_blank" rel="noopener">随时随地让Hexo持续部署</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文章使用Daocloud自动构建发布。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="自动构建" scheme="http://wiliam.me/categories/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="docker" scheme="http://wiliam.me/tags/docker/"/>
    
      <category term="自动构建" scheme="http://wiliam.me/tags/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"/>
    
      <category term="daocloud" scheme="http://wiliam.me/tags/daocloud/"/>
    
  </entry>
  
  <entry>
    <title>git教程分享</title>
    <link href="http://wiliam.me/2017/12/21/20171221092910.html"/>
    <id>http://wiliam.me/2017/12/21/20171221092910.html</id>
    <published>2017-12-21T01:29:10.000Z</published>
    <updated>2022-02-03T12:48:45.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git教程分享"><a href="#git教程分享" class="headerlink" title="git教程分享"></a>git教程分享</h1><p>官方教程地址：<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">简体中文版走你</a></p><blockquote><p>想了解更多技术文章信息，请继续关注<a href="http://wiliam.me">wiliam.s Blog</a>，谢谢，欢迎来访！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git教程分享&quot;&gt;&lt;a href=&quot;#git教程分享&quot; class=&quot;headerlink&quot; title=&quot;git教程分享&quot;&gt;&lt;/a&gt;git教程分享&lt;/h1&gt;&lt;p&gt;官方教程地址：&lt;a href=&quot;https://git-scm.com/book/zh/v2&quot; ta
      
    
    </summary>
    
      <category term="git" scheme="http://wiliam.me/categories/git/"/>
    
    
      <category term="git" scheme="http://wiliam.me/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git的.gitignore文件规则梳理</title>
    <link href="http://wiliam.me/2017/12/20/20171220172910.html"/>
    <id>http://wiliam.me/2017/12/20/20171220172910.html</id>
    <published>2017-12-20T09:29:10.000Z</published>
    <updated>2022-02-03T12:48:45.459Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>.gitignore文件是git使用的管理规则文件，定义哪些可以上传到git服务器，哪些不可上传到服务器，在此在网上搜索了一些规则，自己整理下，做备忘使用，也分享出来方便大家查看。</p></blockquote><a id="more"></a><h1 id="gitignore文件作用"><a href="#gitignore文件作用" class="headerlink" title=".gitignore文件作用"></a>.gitignore文件作用</h1><p>告诉git哪些文件不需要添加到版本管理中。例如IDE的一些配置信息，像eclipse的<code>.settings</code>文件夹和其中的文件,IDEA的<code>.idea</code>目录和其文件等。</p><h1 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h1><p>以斜杠<code>/</code>开头表示目录<br>以星号<code>*</code>通配多个字符<br>以问号<code>?</code>通配单个字符<br>以方括号<code>[]</code>包含单个字符的匹配列表<br>以叹号<code>!</code>表示不忽略(跟踪)匹配到的文件或目录<br>git 对于 <code>.ignore</code> 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ol><li>规则：<code>fd1/*</code>：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；</li><li>规则：<code>/fd1/*</code>：忽略根目录下的 /fd1/ 目录的全部内容；</li><li>规则：规则见下方，含义是忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">!.gitignore</span><br><span class="line">!<span class="regexp">/fw/bin</span><span class="regexp">/</span></span><br><span class="line"><span class="regexp">!/fw</span><span class="regexp">/sf/</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>如果你不慎在创建<code>.gitignore</code>文件之前就push了项目，那么即使你在<code>.gitignore</code>文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。<br>简单来说，出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。因此一定要养成在项目开始就创建<code>.gitignore</code>文件的习惯，否则一旦push，处理起来会非常麻烦</p><blockquote><p>想了解更多技术文章信息，请继续关注<a href="http://wiliam.me">wiliam.s Blog</a>，谢谢，欢迎来访！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;.gitignore文件是git使用的管理规则文件，定义哪些可以上传到git服务器，哪些不可上传到服务器，在此在网上搜索了一些规则，自己整理下，做备忘使用，也分享出来方便大家查看。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="git" scheme="http://wiliam.me/categories/git/"/>
    
    
      <category term="git" scheme="http://wiliam.me/tags/git/"/>
    
      <category term="gitignore" scheme="http://wiliam.me/tags/gitignore/"/>
    
  </entry>
  
  <entry>
    <title>GC Roots</title>
    <link href="http://wiliam.me/2017/09/30/20170930084712.html"/>
    <id>http://wiliam.me/2017/09/30/20170930084712.html</id>
    <published>2017-09-30T00:47:12.000Z</published>
    <updated>2022-02-03T12:48:45.459Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JVM判断对象是否可以回收采用的不是引用计数法，而是可达性分析算法，而通过什么能够判断对象是否可达呢，就是一系列称为GC Roots的对象。</p></blockquote><a id="more"></a><h1 id="可达性算法介绍"><a href="#可达性算法介绍" class="headerlink" title="可达性算法介绍"></a>可达性算法介绍</h1><p>算法基本思路就是通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。就是可以回收的。</p><h2 id="GC-Roots所包含的对象"><a href="#GC-Roots所包含的对象" class="headerlink" title="GC Roots所包含的对象"></a>GC Roots所包含的对象</h2><p>java中，可作为GC Roots的对象包括下面几种</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法中JNI（即一般说的Native方法）引用的对象。</li></ul><blockquote><p>想了解更多技术文章信息，请继续关注<a href="http://wiliam.me">wiliam.s Blog</a>，谢谢，欢迎来访！</p></blockquote><hr><p>参考资料<br>《深入理解Java虚拟机:JVM高级特性与最佳实践》·<font color="gray" size="2">周志明著</font>·<font color="gray" size="2">第二版</font></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JVM判断对象是否可以回收采用的不是引用计数法，而是可达性分析算法，而通过什么能够判断对象是否可达呢，就是一系列称为GC Roots的对象。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="houduan" scheme="http://wiliam.me/categories/houduan/"/>
    
      <category term="JVM" scheme="http://wiliam.me/categories/houduan/JVM/"/>
    
    
      <category term="JVM" scheme="http://wiliam.me/tags/JVM/"/>
    
      <category term="JAVA" scheme="http://wiliam.me/tags/JAVA/"/>
    
      <category term="GC" scheme="http://wiliam.me/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>常用函数时间复杂度收敛状况</title>
    <link href="http://wiliam.me/2017/09/26/20170926081618.html"/>
    <id>http://wiliam.me/2017/09/26/20170926081618.html</id>
    <published>2017-09-26T00:16:18.000Z</published>
    <updated>2022-02-03T12:48:45.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总结了下常用函数的时间复杂度，作为收藏，以备不时之需。数据的每个操作都是有代价的，以时间复杂度和对应查询集或者结果集大小为衡量。</p></blockquote><h1 id="常用时间复杂度收敛状况"><a href="#常用时间复杂度收敛状况" class="headerlink" title="常用时间复杂度收敛状况"></a>常用时间复杂度收敛状况</h1><p><img src="http://imgcdn.yalongkeji.com/suanfa.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;http://imgcdn.yalongkeji.com/suanfa.png&quot;/&gt;
    
    </summary>
    
      <category term="houduan" scheme="http://wiliam.me/categories/houduan/"/>
    
      <category term="算法" scheme="http://wiliam.me/categories/houduan/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wiliam.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>gitbook使用介绍</title>
    <link href="http://wiliam.me/2017/09/01/20170901181618.html"/>
    <id>http://wiliam.me/2017/09/01/20170901181618.html</id>
    <published>2017-09-01T10:16:18.000Z</published>
    <updated>2022-02-03T12:48:45.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>网上冲浪时无意间看到markdown可以写书了，使用的是gitbook-一个先进可定制的文档格式工具。写出的电子书非常好看，所以萌发了自己写一写的念头，俗话说工欲善其事必先利其器，了解gitbook如何使用就很重要了，所以整理了网上各家使用方法，自己又整合了一下。</p><h1 id="截图欣赏"><a href="#截图欣赏" class="headerlink" title="截图欣赏"></a>截图欣赏</h1><p><img src="http://imgcdn.yalongkeji.com/blog/20170901/182505740.png" alt="mark"></p><p><img src="http://imgcdn.yalongkeji.com/blog/20170901/182559088.jpg" alt="mark"></p><p><img src="http://imgcdn.yalongkeji.com/blog/20170901/182615069.jpg" alt="mark"></p><h1 id="书籍地址"><a href="#书籍地址" class="headerlink" title="书籍地址"></a>书籍地址</h1><p><a href="http://gitbook.wiliam.me/" target="_blank" rel="noopener">走你去看书</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;http://imgcdn.yalongkeji.com/blog/20170901/182505740.png&quot;/&gt;
    
    </summary>
    
      <category term="tool" scheme="http://wiliam.me/categories/tool/"/>
    
      <category term="gitbook" scheme="http://wiliam.me/categories/tool/gitbook/"/>
    
    
      <category term="gitbook" scheme="http://wiliam.me/tags/gitbook/"/>
    
  </entry>
  
  <entry>
    <title>【转】Jquery插件开发教程</title>
    <link href="http://wiliam.me/2017/07/03/20170703101403.html"/>
    <id>http://wiliam.me/2017/07/03/20170703101403.html</id>
    <published>2017-07-03T02:14:03.000Z</published>
    <updated>2022-02-03T12:48:45.460Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>要说jQuery 最成功的地方，我认为是它的可扩展性吸引了众多开发者为其开发插件，从而建立起了一个生态系统。这好比大公司们争相做平台一样，得平台者得天下。苹果，微软，谷歌等巨头，都有各自的平台及生态圈</p></blockquote><blockquote><p>学会使用jQuery并不难，因为它简单易学，并且相信你接触jQuery后肯定也使用或熟悉了不少其插件。如果要将能力上升一个台阶，编写一个属于自己的插件是个不错的选择。</p></blockquote><blockquote><p>本教程可能不是最精品的，但一定是最细致的。</p></blockquote><a id="more"></a><h1 id="jQuery插件开发模式"><a href="#jQuery插件开发模式" class="headerlink" title="jQuery插件开发模式"></a>jQuery插件开发模式</h1><p>软件开发过程中是需要一定的设计模式来指导开发的，有了模式，我们就能更好地组织我们的代码，并且从这些前人总结出来的模式中学到很多好的实践。</p><p>根据《jQuery高级编程》的描述，jQuery插件开发方式主要有三种：</p><ol><li>通过$.extend()来扩展jQuery</li><li>通过$.fn 向jQuery添加新的方法</li><li>通过$.widget()应用jQuery UI的部件工厂方式创建</li></ol><p>通常我们使用第二种方法来进行简单插件开发，说简单是相对于第三种方式。第三种方式是用来开发更高级jQuery部件的，该模式开发出来的部件带有很多jQuery内建的特性，比如插件的状态信息自动保存，各种关于插件的常用方法等，非常贴心，这里不细说。</p><p>而第一种方式又太简单，仅仅是在jQuery命名空间或者理解成jQuery身上添加了一个静态方法而以。所以我们调用通过$.extend()添加的函数时直接通过$符号调用（$.myfunction()）而不需要选中DOM元素($(‘#example’).myfunction())。请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.extend(&#123;</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello,'</span> + (name ? name : <span class="string">'Dude'</span>) + <span class="string">'!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">$.sayHello(); <span class="comment">//调用</span></span><br><span class="line">$.sayHello(<span class="string">'Wayou'</span>); <span class="comment">//带参调用</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://images.cnitblog.com/blog/431064/201402/281858071314921.png" alt="运行结果"></p><p>上面代码中，通过$.extend()向jQuery添加了一个sayHello函数，然后通过$直接调用。到此你可以认为我们已经完成了一个简单的jQuery插件了。</p><p>但如你所见，这种方式用来定义一些辅助方法是比较方便的。比如一个自定义的console，输出特定格式的信息，定义一次后可以通过jQuery在程序中任何需要的地方调用它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.extend(&#123;</span><br><span class="line">    log: <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">            y = now.getFullYear(),</span><br><span class="line">            m = now.getMonth() + <span class="number">1</span>, <span class="comment">//！JavaScript中月分是从0开始的</span></span><br><span class="line">            d = now.getDate(),</span><br><span class="line">            h = now.getHours(),</span><br><span class="line">            min = now.getMinutes(),</span><br><span class="line">            s = now.getSeconds(),</span><br><span class="line">            time = y + <span class="string">'/'</span> + m + <span class="string">'/'</span> + d + <span class="string">' '</span> + h + <span class="string">':'</span> + min + <span class="string">':'</span> + s;</span><br><span class="line">        <span class="built_in">console</span>.log(time + <span class="string">' My App: '</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">$.log(<span class="string">'initializing...'</span>); <span class="comment">//调用</span></span><br></pre></td></tr></table></figure><p><img src="http://images.cnitblog.com/i/431064/201402/282326361905458.png" alt="extend"></p><p>但这种方式无法利用jQuery强大的选择器带来的便利，要处理DOM元素以及将插件更好地运用于所选择的元素身上，还是需要使用第二种开发方式。你所见到或使用的插件也大多是通过此种方式开发。</p><hr><h1 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h1><p>下面我们就来看第二种方式的jQuery插件开发。</p><h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><p>先看一下它的基本格式：<br><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.fn.pluginName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//your code goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基本上就是往$.fn上面添加一个方法，名字是我们的插件名称。然后我们的插件代码在这个方法里面展开。</p><p>比如我们将页面上所有链接颜色转成红色，则可以这样写这个插件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//在这里面,this指的是用jQuery选中的元素</span></span><br><span class="line">    <span class="comment">//example :$('a'),则this=$('a')</span></span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'color'</span>, <span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在插件名字定义的这个函数内部，this指代的是我们在调用该插件时，用jQuery选择器选中的元素，一般是一个jQuery类型的集合。比如$(‘a’)返回的是页面上所有a标签的集合，且这个集合已经是jQuery包装类型了，也就是说，在对其进行操作的时候可以直接调用jQuery的其他方法而不需要再用美元符号来包装一下。</p><p>所以在上面插件代码中，我们在this身上调用jQuery的css()方法，也就相当于在调用 $(‘a’).css()。</p><p>理解this在这个地方的含义很重要。这样你才知道为什么可以直接商用jQuery方法同时在其他地方this指代不同时我们又需要用jQuery重新包装才能调用，下面会讲到。初学容易被this的值整晕，但理解了就不难。</p><p>现在就可以去页面试试我们的代码了，在页面上放几个链接，调用插件后链接字体变成红色。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.webo.com/liuwayong"</span>&gt;</span>我的微博<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://http://www.cnblogs.com/Wayou/"</span>&gt;</span>我的博客<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://wayouliu.duapp.com/"</span>&gt;</span>我的小站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是p标签不是a标签，我不会受影响<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery-1.11.0.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.myplugin.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">$(<span class="string">'a'</span>).myPlugin();</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="http://images.cnitblog.com/blog/431064/201402/281858090417237.png" alt="result"><br>下面进一步，在插件代码里处理每个具体的元素，而不是对一个集合进行处理，这样我们就可以针对每个元素进行相应操作。</p><p>我们已经知道this指代jQuery选择器返回的集合，那么通过调用jQuery的.each()方法就可以处理合集中的每个元素了，但此刻要注意的是，在each方法内部，this指带的是普通的DOM元素了，如果需要调用jQuery的方法那就需要用$来重新包装一下。</p><p>比如现在我们要在每个链接显示链接的真实地址，首先通过each遍历所有a标签，然后获取href属性的值再加到链接文本后面。</p><p>更改后我们的插件代码为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//在这里面,this指的是用jQuery选中的元素</span></span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'color'</span>, <span class="string">'red'</span>);</span><br><span class="line">    <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//对每个元素进行操作</span></span><br><span class="line">        $(<span class="keyword">this</span>).append(<span class="string">' '</span> + $(<span class="keyword">this</span>).attr(<span class="string">'href'</span>));</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用代码还是一样的，我们通过选中页面所有的a标签来调用这个插件</p><p>运行结果：</p><p><img src="http://images.cnitblog.com/blog/431064/201402/281858096414351.png" alt="result"></p><p>到此，你已经可以编写功能简单的jQuery插件了。是不是也没那么难。</p><p>下面开始jQuery插件编写中一个重要的部分，参数的接收。</p><h1 id="支持链式调用"><a href="#支持链式调用" class="headerlink" title="支持链式调用"></a>支持链式调用</h1><p>我们都知道jQuery一个时常优雅的特性是支持链式调用，选择好DOM元素后可以不断地调用其他方法。</p><p>要让插件不打破这种链式调用，只需return一下即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//在这里面,this指的是用jQuery选中的元素</span></span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'color'</span>, <span class="string">'red'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//对每个元素进行操作</span></span><br><span class="line">        $(<span class="keyword">this</span>).append(<span class="string">' '</span> + $(<span class="keyword">this</span>).attr(<span class="string">'href'</span>));</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="让插件接收参数"><a href="#让插件接收参数" class="headerlink" title="让插件接收参数"></a>让插件接收参数</h1><p>一个强劲的插件是可以让使用者随意定制的，这要求我们提供在编写插件时就要考虑得全面些，尽量提供合适的参数。</p><p>比如现在我们不想让链接只变成红色，我们让插件的使用者自己定义显示什么颜色，要做到这一点很方便，只需要使用者在调用的时候传入一个参数即可。同时我们在插件的代码里面接收。另一方面，为了灵活，使用者可以不传递参数，插件里面会给出参数的默认值。</p><p>在处理插件参数的接收上，通常使用jQuery的extend方法，上面也提到过，但那是给extend方法传递单个对象的情况下，这个对象会合并到jQuery身上，所以我们就可以在jQuery身上调用新合并对象里包含的方法了，像上面的例子。当给extend方法传递一个以上的参数时，它会将所有参数对象合并到第一个里。同时，如果对象中有同名属性时，合并的时候后面的会覆盖前面的。</p><p>利用这一点，我们可以在插件里定义一个保存插件参数默认值的对象，同时将接收来的参数对象合并到默认对象上，最后就实现了用户指定了值的参数使用指定的值，未指定的参数使用插件默认值。</p><p>为了演示方便，再指定一个参数fontSize，允许调用插件的时候设置字体大小。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = function(options) &#123;</span><br><span class="line">    var defaults = &#123;</span><br><span class="line">        <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">        <span class="string">'fontSize'</span>: <span class="string">'12px'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    var<span class="built_in"> settings </span>= $.extend(defaults, options);</span><br><span class="line">    return this.css(&#123;</span><br><span class="line">        <span class="string">'color'</span>: settings.color,</span><br><span class="line">        <span class="string">'fontSize'</span>: settings.fontSize</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们调用的时候指定颜色，字体大小未指定，会运用插件里的默认值12px。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$('a').myPlugin(&#123;</span><br><span class="line">    'color': '#2C<span class="number">9929</span>'</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://images.cnitblog.com/blog/431064/201402/281858102422938.png" alt="结果1"></p><p>同时指定颜色与字体大小：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$('a').myPlugin(&#123;</span><br><span class="line">    'color': '#2C<span class="number">9929</span>',</span><br><span class="line">    'fontSize': '20px'</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="http://images.cnitblog.com/blog/431064/201402/281858108955539.png" alt="结果2"></p><h1 id="保护好默认参数"><a href="#保护好默认参数" class="headerlink" title="保护好默认参数"></a>保护好默认参数</h1><p>注意到上面代码调用extend时会将defaults的值改变，这样不好，因为它作为插件因有的一些东西应该维持原样，另外就是如果你在后续代码中还要使用这些默认值的话，当你再次访问它时它已经被用户传进来的参数更改了。<br><img src="http://images.cnitblog.com/blog/431064/201402/281858115012654.png" alt="结果3"></p><p>一个好的做法是将一个新的空对象做为$.extend的第一个参数，defaults和用户传递的参数对象紧随其后，这样做的好处是所有值被合并到这个空对象上，保护了插件里面的默认值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> defaults = &#123;</span><br><span class="line">        <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">        <span class="string">'fontSize'</span>: <span class="string">'12px'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> settings = $.extend(&#123;&#125;,defaults, options);<span class="comment">//将一个空对象做为第一个参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.css(&#123;</span><br><span class="line">        <span class="string">'color'</span>: settings.color,</span><br><span class="line">        <span class="string">'fontSize'</span>: settings.fontSize</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此，插件可以接收和处理参数后，就可以编写出更健壮而灵活的插件了。若要编写一个复杂的插件，代码量会很大，如何组织代码就成了一个需要面临的问题，没有一个好的方式来组织这些代码，整体感觉会杂乱无章，同时也不好维护，所以将插件的所有方法属性包装到一个对象上，用面向对象的思维来进行开发，无疑会使工作轻松很多。</p><h1 id="面向对象的插件开发"><a href="#面向对象的插件开发" class="headerlink" title="面向对象的插件开发"></a>面向对象的插件开发</h1><p>为什么要有面向对象的思维，因为如果不这样，你可能需要一个方法的时候就去定义一个function，当需要另外一个方法的时候，再去随便定义一个function，同样，需要一个变量的时候，毫无规则地定义一些散落在代码各处的变量。</p><p>还是老问题，不方便维护，也不够清晰。当然，这些问题在代码规模较小时是体现不出来的。</p><p>如果将需要的重要变量定义到对象的属性上，函数变成对象的方法，当我们需要的时候通过对象来获取，一来方便管理，二来不会影响外部命名空间，因为所有这些变量名还有方法名都是在对象内部。</p><p>接着上面的例子，我们可以把这个插件抽象成一个美化页面的对象，因为他的功能是设置颜色啊字体啊什么的，当然我们还可以加入其他功能比如设置下划线啊什么的。当然对于这个例子抽象成对象有点小题大做，这里仅作演示用。以后我可能会介绍我编写的一个jQuery插件SlipHover,其中代码就比较多，这样的模式就用得上了。</p><p>所以我们新建一个对象命名为Beautifier，然后我们在插件里使用这个对象来编码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义Beautifier的构造函数</span></span><br><span class="line"><span class="keyword">var</span> Beautifier = <span class="function"><span class="keyword">function</span>(<span class="params">ele, opt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$element = ele,</span><br><span class="line">    <span class="keyword">this</span>.defaults = &#123;</span><br><span class="line">        <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">        <span class="string">'fontSize'</span>: <span class="string">'12px'</span>,</span><br><span class="line">        <span class="string">'textDecoration'</span>:<span class="string">'none'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">this</span>.options = $.extend(&#123;&#125;, <span class="keyword">this</span>.defaults, opt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Beautifier的方法</span></span><br><span class="line">Beautifier.prototype = &#123;</span><br><span class="line">    beautify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$element.css(&#123;</span><br><span class="line">            <span class="string">'color'</span>: <span class="keyword">this</span>.options.color,</span><br><span class="line">            <span class="string">'fontSize'</span>: <span class="keyword">this</span>.options.fontSize,</span><br><span class="line">            <span class="string">'textDecoration'</span>: <span class="keyword">this</span>.options.textDecoration</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在插件中使用Beautifier对象</span></span><br><span class="line">$.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建Beautifier的实体</span></span><br><span class="line">    <span class="keyword">var</span> beautifier = <span class="keyword">new</span> Beautifier(<span class="keyword">this</span>, options);</span><br><span class="line">    <span class="comment">//调用其方法</span></span><br><span class="line">    <span class="keyword">return</span> beautifier.beautify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这样一改造，我们的代码变得更面向对象了，也更好维护和理解，以后要加新功能新方法，只需向对象添加新变量及方法即可，然后在插件里实例化后即可调用新添加的东西。</p><p>插件的调用还是一样的，我们对代码的改动并不影响插件其他地方，只是将代码的组织结构改动了而以。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'a'</span>).myPlugin(&#123;</span><br><span class="line">        <span class="string">'color'</span>: <span class="string">'#2C9929'</span>,</span><br><span class="line">        <span class="string">'fontSize'</span>: <span class="string">'20px'</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="http://images.cnitblog.com/blog/431064/201402/281858120772997.png" alt="结果4"></p><p>指定文字带下划线（我们在Beautifier对象中新加的功能，默认不带下划线，如上面的例子）的调用：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'a'</span>).myPlugin(&#123;</span><br><span class="line">        <span class="string">'color'</span>: <span class="string">'#2C9929'</span>,</span><br><span class="line">        <span class="string">'fontSize'</span>: <span class="string">'20px'</span>,</span><br><span class="line">        <span class="string">'textDecoration'</span>: <span class="string">'underline'</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="http://images.cnitblog.com/blog/431064/201402/281858125256069.png" alt="结果5"></p><p>到这里，你可以更好地编写复杂的插件同时很好地组织代码了。当我们回头去看上面的代码时，其实也还是有改进空间的。也就是下面介绍的关于命名空间及变量各什么的，一些杂项。</p><h1 id="关于命名空间"><a href="#关于命名空间" class="headerlink" title="关于命名空间"></a>关于命名空间</h1><p>不仅仅是jQuery插件的开发，我们在写任何JS代码时都应该注意的一点是不要污染全局命名空间。因为随着你代码的增多，如果有意无意在全局范围内定义一些变量的话，最后很难维护，也容易跟别人写的代码有冲突。</p><p>比如你在代码中向全局window对象添加了一个变量status用于存放状态，同时页面中引用了另一个别人写的库，也向全局添加了这样一个同名变量，最后的结果肯定不是你想要的。所以不到万不得已，一般我们不会将变量定义成全局的。</p><p>一个好的做法是始终用自调用匿名函数包裹你的代码，这样就可以完全放心，安全地将它用于任何地方了，绝对没有冲突。</p><h2 id="用自调用匿名函数包裹你的代码"><a href="#用自调用匿名函数包裹你的代码" class="headerlink" title="用自调用匿名函数包裹你的代码"></a>用自调用匿名函数包裹你的代码</h2><p>我们知道JavaScript中无法用花括号方便地创建作用域，但函数却可以形成一个作用域，域内的代码是无法被外界访问的。如果我们将自己的代码放入一个函数中，那么就不会污染全局命名空间，同时不会和别的代码冲突。</p><p>如上面我们定义了一个Beautifier全局变量，它会被附到全局的window对象上，为了防止这种事情发生，你或许会说，把所有代码放到jQuery的插件定义代码里面去啊，也就是放到$.fn.myPlugin里面。这样做倒也是种选择。但会让我们实际跟插件定义有关的代码变得臃肿，而在$.fn.myPlugin里面我们其实应该更专注于插件的调用，以及如何与jQuery互动。</p><p>所以保持原来的代码不变，我们将所有代码用自调用匿名函数包裹。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义Beautifier的构造函数</span></span><br><span class="line">    <span class="keyword">var</span> Beautifier = <span class="function"><span class="keyword">function</span>(<span class="params">ele, opt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.$element = ele,</span><br><span class="line">        <span class="keyword">this</span>.defaults = &#123;</span><br><span class="line">            <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">            <span class="string">'fontSize'</span>: <span class="string">'12px'</span>,</span><br><span class="line">            <span class="string">'textDecoration'</span>: <span class="string">'none'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">this</span>.options = $.extend(&#123;&#125;, <span class="keyword">this</span>.defaults, opt)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义Beautifier的方法</span></span><br><span class="line">    Beautifier.prototype = &#123;</span><br><span class="line">        beautify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$element.css(&#123;</span><br><span class="line">                <span class="string">'color'</span>: <span class="keyword">this</span>.options.color,</span><br><span class="line">                <span class="string">'fontSize'</span>: <span class="keyword">this</span>.options.fontSize,</span><br><span class="line">                <span class="string">'textDecoration'</span>: <span class="keyword">this</span>.options.textDecoration</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在插件中使用Beautifier对象</span></span><br><span class="line">    $.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//创建Beautifier的实体</span></span><br><span class="line">        <span class="keyword">var</span> beautifier = <span class="keyword">new</span> Beautifier(<span class="keyword">this</span>, options);</span><br><span class="line">        <span class="comment">//调用其方法</span></span><br><span class="line">        <span class="keyword">return</span> beautifier.beautify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这样做的好处，也就是上面所阐述的那样。另外还有一个好处就是，自调用匿名函数里面的代码会在第一时间执行，页面准备好过后，上面的代码就将插件准备好了，以方便在后面的代码中使用插件。</p><p>目前为止似乎接近完美了。如果再考虑到其他一些因素，比如我们将这段代码放到页面后，前面别人写的代码没有用分号结尾，或者前面的代码将window, undefined等这些系统变量或者关键字修改掉了，正好我们又在自己的代码里面进行了使用，那结果也是不可预测的，这不是 我们想要的。我知道其实你还没太明白，下面详细介绍。</p><h2 id="将系统变量以变量形式传递到插件内部"><a href="#将系统变量以变量形式传递到插件内部" class="headerlink" title="将系统变量以变量形式传递到插件内部"></a>将系统变量以变量形式传递到插件内部</h2><p>来看下面的代码，你猜他会出现什么结果？</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//别人的代码</span></span><br><span class="line">&#125;<span class="comment">//注意这里没有用分号结尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始我们的代码。。。</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//我们的代码。。</span></span><br><span class="line">    alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>本来别人的代码也正常工作，只是最后定义的那个函数没有用分号结尾而以，然后当页面中引入我们的插件时，报错了，我们的代码无法正常执行。</p><p><img src="http://images.cnitblog.com/blog/431064/201402/281858132263684.png" alt="结果2"></p><p>原因是我们用来充当自调用匿名函数的第一对括号与上面别人定义的函数相连，因为中间没有分号嘛，总之我们的代码无法正常解析了，所以报错。</p><p>所以好的做法是我们在代码开头加一个分号，这在任何时候都是一个好的习惯。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//别人的代码</span></span><br><span class="line">&#125;<span class="comment">//注意这里没有用分号结尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始我们的代码。。。</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//我们的代码。。</span></span><br><span class="line">    alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>同时，将系统变量以参数形式传递到插件内部也是个不错的实践。</p><p>当我们这样做之后，window等系统变量在插件内部就有了一个局部的引用，可以提高访问速度，会有些许性能的提升</p><p>最后我们得到一个非常安全结构良好的代码：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">$,<span class="built_in">window</span>,<span class="built_in">document</span>,<span class="literal">undefined</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//我们的代码。。</span></span><br><span class="line">    <span class="comment">//blah blah blah...</span></span><br><span class="line">&#125;)(jQuery,<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure></p><p>而至于这个undefined，稍微有意思一点，为了得到没有被修改的undefined，我们并没有传递这个参数，但却在接收时接收了它，因为实际并没有传，所以‘undefined’那个位置接收到的就是真实的’undefined’了。是不是有点hack的味道，值得细细体会的技术，当然不是我发明的，都是从前人的经验中学习。</p><p>所以最后我们的插件成了这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">$, window, document,undefined</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义Beautifier的构造函数</span></span><br><span class="line">    <span class="keyword">var</span> Beautifier = <span class="function"><span class="keyword">function</span>(<span class="params">ele, opt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.$element = ele,</span><br><span class="line">        <span class="keyword">this</span>.defaults = &#123;</span><br><span class="line">            <span class="string">'color'</span>: <span class="string">'red'</span>,</span><br><span class="line">            <span class="string">'fontSize'</span>: <span class="string">'12px'</span>,</span><br><span class="line">            <span class="string">'textDecoration'</span>: <span class="string">'none'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">this</span>.options = $.extend(&#123;&#125;, <span class="keyword">this</span>.defaults, opt)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义Beautifier的方法</span></span><br><span class="line">    Beautifier.prototype = &#123;</span><br><span class="line">        beautify: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$element.css(&#123;</span><br><span class="line">                <span class="string">'color'</span>: <span class="keyword">this</span>.options.color,</span><br><span class="line">                <span class="string">'fontSize'</span>: <span class="keyword">this</span>.options.fontSize,</span><br><span class="line">                <span class="string">'textDecoration'</span>: <span class="keyword">this</span>.options.textDecoration</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在插件中使用Beautifier对象</span></span><br><span class="line">    $.fn.myPlugin = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//创建Beautifier的实体</span></span><br><span class="line">        <span class="keyword">var</span> beautifier = <span class="keyword">new</span> Beautifier(<span class="keyword">this</span>, options);</span><br><span class="line">        <span class="comment">//调用其方法</span></span><br><span class="line">        <span class="keyword">return</span> beautifier.beautify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery, <span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>一个安全，结构良好，组织有序的插件编写完成。</p><h1 id="关于变量定义及命名"><a href="#关于变量定义及命名" class="headerlink" title="关于变量定义及命名"></a>关于变量定义及命名</h1><p>现在谈谈关于变量及方法等的命名，没有硬性规定，但为了规范，遵循一些约定还是很有必要的。</p><p><strong>变量定义：</strong>好的做法是把将要使用的变量名用一个var关键字一并定义在代码开头，变量名间用逗号隔开。原因有二：</p><ul><li>一是便于理解，知道下面的代码会用到哪些变量，同时代码显得整洁且有规律，也方便管理，变量定义与逻辑代码分开；</li><li>二是因为JavaScript中所有变量及函数名会自动提升，也称之为JavaScript的Hoist特性，即使你将变量的定义穿插在逻辑代码中，在代码解析运行期间，这些变量的声明还是被提升到了当前作用域最顶端的，所以我们将变量定义在一个作用域的开头是更符合逻辑的一种做法。当然，再次说明这只是一种约定，不是必需的。</li></ul><p><strong>变量及函数命名</strong> 一般使用驼峰命名法（CamelCase），即首个单词的首字母小写，后面单词首字母大写，比如resultArray，requestAnimationFrame。对于常量，所有字母采用大写，多个单词用下划线隔开，比如WIDTH=100，BRUSH_COLOR=’#00ff00’。当变量是jQuery类型时，建议以$开头，开始会不习惯，但经常用了之后会感觉很方便，因为可以很方便地将它与普通变量区别开来，一看到以$开头我们就知道它是jQuery类型可以直接在其身上调用jQuery相关的方法，比如var $element=$(‘a’); 之后就可以在后面的代码中很方便地使用它，并且与其他变量容易区分开来。</p><p><strong>引号的使用：</strong>既然都扯了这些与插件主题无关的了，这里再多说一句，一般HTML代码里面使用双引号，而在JavaScript中多用单引号，比如下面代码所示：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">name</span> = <span class="string">'Wayou'</span>;</span><br><span class="line">document.getElementById(‘example’).innerHTML = <span class="string">'&lt; a href="http: //wayouliu.duapp.com/"&gt;'</span>+<span class="keyword">name</span>+<span class="string">'&lt;/a&gt;'</span>; <span class="comment">//href=".." HTML中保持双引号，JavaScript中保持单引号</span></span><br></pre></td></tr></table></figure></p><p>一方面，HTML代码中本来就使用的是双引号，另一方面，在JavaScript中引号中还需要引号的时候，要求我们单双引号间隔着写才是合法的语句，除非你使用转意符那也是可以的。再者，坚持这样的统一可以保持代码风格的一致，不会出现这里字符串用双引号包着，另外的地方就在用单引号。</p><p> <a href="http://www.cnblogs.com/Wayou/p/jquery_plugin_tutorial.html" target="_blank" rel="noopener">原文出处</a></p><blockquote><p>想了解更多技术文章信息，请继续关注<a href="http://wiliam.me">wiliam.s Blog</a>，谢谢，欢迎来访！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;要说jQuery 最成功的地方，我认为是它的可扩展性吸引了众多开发者为其开发插件，从而建立起了一个生态系统。这好比大公司们争相做平台一样，得平台者得天下。苹果，微软，谷歌等巨头，都有各自的平台及生态圈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;学会使用jQuery并不难，因为它简单易学，并且相信你接触jQuery后肯定也使用或熟悉了不少其插件。如果要将能力上升一个台阶，编写一个属于自己的插件是个不错的选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;本教程可能不是最精品的，但一定是最细致的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="qianduan" scheme="http://wiliam.me/categories/qianduan/"/>
    
      <category term="jquery" scheme="http://wiliam.me/categories/qianduan/jquery/"/>
    
    
      <category term="jquery" scheme="http://wiliam.me/tags/jquery/"/>
    
      <category term="插件" scheme="http://wiliam.me/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解javascript原型和闭包电子书</title>
    <link href="http://wiliam.me/2017/04/23/20170423114940.html"/>
    <id>http://wiliam.me/2017/04/23/20170423114940.html</id>
    <published>2017-04-23T03:49:40.000Z</published>
    <updated>2022-02-03T12:48:45.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在写前端的代码，顺便就再学习巩固下JavaScript，在网上看见了对JavaScript的原型和闭包讲解的很透彻的博客。自己就摘过来做成了电子书，分享出来，供大家学习参考。</p></blockquote><h1 id="书籍说明"><a href="#书籍说明" class="headerlink" title="书籍说明"></a>书籍说明</h1><p>本书是对<a href="http://www.cnblogs.com/wangfupeng1988/p/3977924.html" target="_blank" rel="noopener">深入理解javascript原型和闭包</a>系列博客的整理，该博客的作者是<strong>王福朋</strong>,在此感谢王老师。整理人：<a href="http://wiliam.top" target="_blank" rel="noopener">wiliam</a></p><h1 id="为什么会整理成电子书"><a href="#为什么会整理成电子书" class="headerlink" title="为什么会整理成电子书"></a>为什么会整理成电子书</h1><p>之前学习JavaScript就对原型和闭包的概念不是很理解，总是晕乎乎的，无意间看到了王老师写的<a href="http://www.cnblogs.com/wangfupeng1988/p/3977924.html" target="_blank" rel="noopener">深入理解javascript原型和闭包</a>教程，有醍醐灌顶之感，<strong>王老师</strong>讲的很透彻，所以有想要将这系列收藏做成自己的知识储备，以后可以随时随地的巩固消化。最后整理出来了本电子书，在此分享出来，也希望大家看后对javascript原型和闭包的概念有所收获。最后再次感谢<strong>王老师</strong>。</p><h1 id="书籍地址："><a href="#书籍地址：" class="headerlink" title="书籍地址："></a>书籍地址：</h1><p><a href="http://jsprototype.wiliam.me" target="_blank" rel="noopener">博客阅读地址</a><br><a href="https://wiliam2015.gitbooks.io/jsprototype" target="_blank" rel="noopener">gitbook地址</a></p><blockquote><p>想了解更多技术文章信息，请继续关注<a href="http://wiliam.me">wiliam.s Blog</a>，谢谢，欢迎来访！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;http://imgcdn.yalongkeji.com/blog/20170423/130114508.png&quot;/&gt;
    
    </summary>
    
      <category term="qianduan" scheme="http://wiliam.me/categories/qianduan/"/>
    
      <category term="javascript" scheme="http://wiliam.me/categories/qianduan/javascript/"/>
    
    
      <category term="javascript" scheme="http://wiliam.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Spring的AOP实现源码分析</title>
    <link href="http://wiliam.me/2017/04/02/20170402114321.html"/>
    <id>http://wiliam.me/2017/04/02/20170402114321.html</id>
    <published>2017-04-02T03:43:21.000Z</published>
    <updated>2022-02-03T12:48:45.462Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们经常使用spring的aop功能，比如声明性事务，日志打印等。但其原理是什么呢，接下来我们就详细分析spring的AOP实现原理。<br><a id="more"></a></p></blockquote><p>使用Spring的AOP功能我们需要开启才能使用，Spring给我们提供了自定义标签启用AOP的功能。AOP常用的两个标签<code>&lt;aop:aspectj-autoproxy /&gt;</code>使用注解启用AOP功能，<code>&lt;aop:config&gt;</code>使用xml配置启用AOP功能。我们分析AOP的实现也是从这两个标签开始。</p><h1 id="1-自定义标签解析源码分析"><a href="#1-自定义标签解析源码分析" class="headerlink" title="1.自定义标签解析源码分析"></a>1.自定义标签解析源码分析</h1><p>默认的bean标签，我们通过class属性就知道注册了哪些类。自定义标签是不知道的，所以需要看源码。我们看自定义标签的解析，说白了也就是看Spring给我们默认注入了哪些bean类。<br>aop标签解析的整个类是<code>org.springframework.aop.config. AopNamespaceHandler</code>。</p><h2 id="1-1-lt-aop-aspectj-autoproxy-gt-标签解析"><a href="#1-1-lt-aop-aspectj-autoproxy-gt-标签解析" class="headerlink" title="1.1 &lt;aop:aspectj-autoproxy/&gt;标签解析"></a>1.1 &lt;aop:aspectj-autoproxy/&gt;标签解析</h2><p>从<code>AopNamespaceHandler</code>类的init方法中知道<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a>标签解析使用的是<code>AspectJAutoProxyBeanDefinitionParser</code>类，从<code>AspectJAutoProxyBeanDefinitionParser</code>类的init方法中我们看到注册<code>AnnotationAwareAspectJAutoProxyCreator</code>代理类。</p><h2 id="1-2-lt-aop-config-gt-标签解析"><a href="#1-2-lt-aop-config-gt-标签解析" class="headerlink" title="1.2 &lt; aop:config &gt;标签解析"></a>1.2 &lt; aop:config &gt;标签解析</h2><p>从<code>AopNamespaceHandler</code>类的init方法中知道config标签的解析使用<code>ConfigBeanDefinitionParser</code>类<br>进入此类的parse方法。在parse方法中开头注册了<code>AspectJAwareAdvisorAutoProxyCreator</code>代理，接着会对<a href="aop:config" target="_blank" rel="noopener">aop:config</a>下的三个子标签分别解析，三个子标签是<code>&lt;aop:pointcut&gt;</code>,<code>&lt;aop:advisor&gt;</code>,<code>&lt;aop:aspect&gt;</code>。</p><h3 id="1-2-1-lt-aop-pointcut-gt-子标签解析"><a href="#1-2-1-lt-aop-pointcut-gt-子标签解析" class="headerlink" title="1.2.1 &lt;aop:pointcut &gt;子标签解析"></a>1.2.1 &lt;aop:pointcut &gt;子标签解析</h3><p>注册<code>AspectJExpressionPointcut</code>类，scope是prototype</p><h3 id="1-2-2-lt-aop-advisor-gt-子标签解析"><a href="#1-2-2-lt-aop-advisor-gt-子标签解析" class="headerlink" title="1.2.2 &lt;aop:advisor &gt;子标签解析"></a>1.2.2 &lt;aop:advisor &gt;子标签解析</h3><p>解析此标签时注册了以下bean：<br><code>DefaultBeanFactoryPointcutAdvisor</code><br><code>AspectJExpressionPointcut</code>，scope是prototype</p><h3 id="1-2-3-lt-aop-aspect-gt-子标签解析"><a href="#1-2-3-lt-aop-aspect-gt-子标签解析" class="headerlink" title="1.2.3 &lt;aop:aspect &gt;子标签解析"></a>1.2.3 &lt;aop:aspect &gt;子标签解析</h3><p>此标签如果下面存在<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>子标签会调用解析<a href="aop:pointcut" target="_blank" rel="noopener">aop:pointcut</a>代码去解析。<br>其余会注册<code>MethodLocatingFactoryBean</code>,<code>SimpleBeanFactoryAwareAspectInstanceFactory</code>和<code>AspectJPointcutAdvisor</code>类还会针对before，after，around，after-returning,after-throwing标签增加不同的bean，如下：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">BEFORE</span>.</span></span>equals(elementName)) &#123;</span><br><span class="line">            return <span class="module-access"><span class="module"><span class="identifier">AspectJMethodBeforeAdvice</span>.</span></span><span class="keyword">class</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">AFTER</span>.</span></span>equals(elementName)) &#123;</span><br><span class="line">            return <span class="module-access"><span class="module"><span class="identifier">AspectJAfterAdvice</span>.</span></span><span class="keyword">class</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">AFTER_RETURNING_ELEMENT</span>.</span></span>equals(elementName)) &#123;</span><br><span class="line">            return <span class="module-access"><span class="module"><span class="identifier">AspectJAfterReturningAdvice</span>.</span></span><span class="keyword">class</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">AFTER_THROWING_ELEMENT</span>.</span></span>equals(elementName)) &#123;</span><br><span class="line">            return <span class="module-access"><span class="module"><span class="identifier">AspectJAfterThrowingAdvice</span>.</span></span><span class="keyword">class</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">AROUND</span>.</span></span>equals(elementName)) &#123;</span><br><span class="line">            return <span class="module-access"><span class="module"><span class="identifier">AspectJAroundAdvice</span>.</span></span><span class="keyword">class</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-使用分析"><a href="#2-使用分析" class="headerlink" title="2.使用分析"></a>2.使用分析</h1><h2 id="2-1-lt-aop-aspectj-autoproxy-gt-使用分析"><a href="#2-1-lt-aop-aspectj-autoproxy-gt-使用分析" class="headerlink" title="2.1 &lt;aop:aspectj-autoproxy/&gt;使用分析"></a>2.1 &lt;aop:aspectj-autoproxy/&gt;使用分析</h2><p>我们在spring配置文件中加入<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a>这个标签后，就可以在类中使用aop注解了，但背后的原理是什么呢。从1.1<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a>标签解析 中我们知道解析此标签时注册了<code>AnnotationAwareAspectJAutoProxyCreator</code>的bean，那么分析aop注解的使用也是从此类开始。<br><code>AnnotationAwareAspectJAutoProxyCreator</code>的继承关系如下：<br><img src="http://imgcdn.yalongkeji.com/blog/20170402/114909576.png" alt="springaop"></p><p> 可以看到实现了<code>BeanPostProcessor</code>接口，<code>BeanPostProcessor</code>接口是spring的重要接口<code>BeanPostProcessor</code>源码如下。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface BeanPostProcessor &#123;</span><br><span class="line">        <span class="comment">//初始化前调用</span></span><br><span class="line"><span class="keyword">Object</span> postProcessBeforeInitialization(<span class="keyword">Object</span> bean, <span class="keyword">String</span> beanName) <span class="keyword">throws</span> BeansException;</span><br><span class="line">        <span class="comment">//初始化后调用</span></span><br><span class="line"><span class="keyword">Object</span> postProcessAfterInitialization(<span class="keyword">Object</span> bean, <span class="keyword">String</span> beanName) <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们使用ApplicationContext相关实现类的上下文时，spring会保证前者在实例化及依赖注入完成后，在任何初始化代码（比如配置文件中的init-method）调用之前调用；后者在初始化代码调用之后调用。</p><p><code>InstantiationAwareBeanPostProcessor</code>是<code>BeanPostProcessor</code>的子接口，可以在Bean生命周期的另外两个时期提供扩展的回调接口，即实例化Bean之前（调用<code>postProcessBeforeInstantiation</code>方法）和实例化Bean之后（调用<code>postProcessAfterInstantiation</code>方法），该接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="comment">//实例化前调用</span></span><br><span class="line"><span class="function">Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化后调用</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装配属性时调用</span></span><br><span class="line"><span class="function">PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们分析也是从这些接口的实现方法入手<br>BeanPostProcessor .postProcessBeforeInitialization空实现<br>BeanPostProcessor .postProcessAfterInitialization方法实现如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a proxy with the configured interceptors if the bean is</span></span><br><span class="line"><span class="comment"> * identified as one to proxy by the subclass.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getAdvicesAndAdvisorsForBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根据给定的bean的class和name构建出个key，格式beanClassName_beanName</span></span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">            <span class="comment">//如果适合被代理，则需要封装指定的bean</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.containsKey(cacheKey)) &#123;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean the raw bean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cacheKey the cache key for metadata access</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a proxy wrapping the bean, or the raw bean instance as-is</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;</span><br><span class="line"><span class="comment">//如果bean已经被处理过</span></span><br><span class="line"><span class="keyword">if</span> (beanName != <span class="literal">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.containsKey(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果bean无需增强</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>.FALSE.equals(<span class="keyword">this</span>.advisedBeans.<span class="keyword">get</span>(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果bean类是一个基础设施类，基础设施类不应该代理，或者配置了指定bean不需要自动代理</span></span><br><span class="line"><span class="comment">//如果bean是Advice,Advisor和AopInfrastructureBean的实例代表是基础设置类</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, <span class="built_in">Boolean</span>.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在增强方法则创建代理</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//如果获取到了增强则需要针对增强创建代理</span></span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="comment">//将创建的代理bean放到advisedBeans中，用于前面的判断</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, <span class="built_in">Boolean</span>.TRUE);</span><br><span class="line"><span class="comment">//创建代理</span></span><br><span class="line">Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将创建的代理bean放到advisedBeans中，用于前面的判断</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, <span class="built_in">Boolean</span>.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到Spring代码的精巧，先构建出骨架然后在逐步完善，在函数中我们可以看到代理创建的雏形。当然在正式开始之前需要经过一些判断，比如是否已经处理过或者是否需要跳过的bean。Spring真正开始创建代理是从<code>Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</code>代码及以下开始的。</p><p>创建代理主要包含了两个步骤：</p><ol><li>获取增强方法或者增强器</li><li>根据获取的增强进行代理<br>下面逐步分析</li></ol><h3 id="2-1-1获取增强方法或者增强器"><a href="#2-1-1获取增强方法或者增强器" class="headerlink" title="2.1.1获取增强方法或者增强器"></a>2.1.1获取增强方法或者增强器</h3><p>AbstractAdvisorAutoProxyCreator.java类对getAdvicesAndAdvisorsForBean方法重写，代码如下：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected Object<span class="literal">[]</span> get<span class="constructor">AdvicesAndAdvisorsForBean(Class <span class="params">beanClass</span>, String <span class="params">beanName</span>, TargetSource <span class="params">targetSource</span>)</span> &#123;</span><br><span class="line">                <span class="comment">//查找合适的增强</span></span><br><span class="line">List advisors = find<span class="constructor">EligibleAdvisors(<span class="params">beanClass</span>, <span class="params">beanName</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (advisors.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">return DO_NOT_PROXY;</span><br><span class="line">&#125;</span><br><span class="line">return advisors.<span class="keyword">to</span><span class="constructor">Array()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find all eligible Advisors for auto-proxying this class.</span></span><br><span class="line"><span class="comment"> * @param beanClass the clazz to find advisors for</span></span><br><span class="line"><span class="comment"> * @param beanName the name of the currently proxied bean</span></span><br><span class="line"><span class="comment"> * @return the empty List, not &#123;@code null&#125;,</span></span><br><span class="line"><span class="comment"> * if there are no pointcuts or interceptors</span></span><br><span class="line"><span class="comment"> * @see #findCandidateAdvisors</span></span><br><span class="line"><span class="comment"> * @see #sortAdvisors</span></span><br><span class="line"><span class="comment"> * @see #extendAdvisors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">protected List&lt;Advisor&gt; find<span class="constructor">EligibleAdvisors(Class <span class="params">beanClass</span>, String <span class="params">beanName</span>)</span> &#123;</span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = find<span class="constructor">CandidateAdvisors()</span>;</span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = find<span class="constructor">AdvisorsThatCanApply(<span class="params">candidateAdvisors</span>, <span class="params">beanClass</span>, <span class="params">beanName</span>)</span>;</span><br><span class="line">extend<span class="constructor">Advisors(<span class="params">eligibleAdvisors</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (!eligibleAdvisors.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">eligibleAdvisors = sort<span class="constructor">Advisors(<span class="params">eligibleAdvisors</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">return eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里说下Spring中的Advisor。Advisor充当Advice和Pointcut的适配器。包括Pointcut和Advice，是将Advice注入程序中Pointcut位置的代码。<br>我们可以看到Spring又是层层构建，清晰的描绘了aop的实现逻辑<code>findEligibleAdvisors</code>方法中做了两件事:</p><ol><li>获取所有的增强。</li><li>找到所有增强中适用于bean的增强并应用。如果找不到变会返回空了。</li></ol><p>由于我们分析的是使用注解进行的aop，即最终的代理处理类是<code>AnnotationAwareAspectJAutoProxyCreator</code>，此类中重写了<code>findCandidateAdvisors</code>方法，此方法如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; findCandidateAdvisors() &#123;</span><br><span class="line"><span class="comment">//获取父类中加载配置文件中的aop声明，使用注解配置aop并不是丢弃了对xml配置的支持。</span></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line"><span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line">advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用父类中的方法<code>super.findCandidateAdvisors()</code>主要是从配置文件中查找所有实现了<code>Advisor</code>接口的bean，这里就不在分析，代码逻辑很清晰，感兴趣的读者可以自己分析下。<br>接下来的第二行就是查找标记了aop注解的bean并增加到结果集中。而使用的代码点就是<code>this.aspectJAdvisorsBuilder.buildAspectJAdvisors()</code>,该方法整体逻辑如下：</p><ol><li>获取所有beanName，这一步中所有在beanFactory中注册的bean都会被提取出来。</li><li>遍历所有beanName，找出声明AspectJ注解的类，进行进一步的处理。</li><li>对标记为AspectJ注解的类进行增强器的提取。</li><li>将提取结果加入结果集。</li></ol><p>方法代码如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"> * Look <span class="keyword">for</span> AspectJ-annotated aspect beans <span class="keyword">in</span> the current bean factory,</span><br><span class="line"> * and <span class="keyword">return</span> to a list of Spring AOP Advisors representing them.</span><br><span class="line"> * &lt;p&gt;Creates a Spring Advisor <span class="keyword">for</span> each AspectJ advice method.</span><br><span class="line"> * <span class="meta">@return</span> the list of &#123;<span class="meta">@link</span> org.springframework.aop.Advisor&#125; beans</span><br><span class="line"> * <span class="meta">@see</span> #isEligibleBean</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> List&lt;Advisor&gt; buildAspectJAdvisors() &#123;</span><br><span class="line">List&lt;String&gt; aspectNames = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line">List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;();</span><br><span class="line">aspectNames = new LinkedList&lt;String&gt;();</span><br><span class="line"><span class="comment">//获取所有的beanName</span></span><br><span class="line">String[] beanNames =</span><br><span class="line">BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<span class="keyword">this</span>.beanFactory, Object<span class="class">.<span class="keyword">class</span>, <span class="type">true</span>, <span class="type">false);</span></span></span><br><span class="line"><span class="comment">//循环所有的beanName 找出对应的增强方法</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="comment">//不合法的bean则略过，有子类定义规则默认返回true</span></span><br><span class="line"><span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// We must be careful not to instantiate beans eagerly as in this</span></span><br><span class="line"><span class="comment">// case they would be cached by the Spring container but would not</span></span><br><span class="line"><span class="comment">// have been weaved</span></span><br><span class="line"><span class="comment">//获取对应的bean的类型</span></span><br><span class="line">Class beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line"><span class="keyword">if</span> (beanType == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果存在Aspect注解</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">aspectNames.add(beanName);</span><br><span class="line">AspectMetadata amd = new AspectMetadata(beanType, beanName);</span><br><span class="line"><span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">new BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line"><span class="comment">//解析标记AspectJ注解中的增强方法</span></span><br><span class="line">List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">&#125;</span><br><span class="line">advisors.addAll(classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Per target or per this.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> new IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line"><span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">&#125;</span><br><span class="line">MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">new PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line"><span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> Collections.EMPTY_LIST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将结果集记录在结果中</span></span><br><span class="line">List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;();</span><br><span class="line"><span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">List&lt;Advisor&gt; cachedAdvisors = <span class="keyword">this</span>.advisorsCache.<span class="keyword">get</span>(aspectName);</span><br><span class="line"><span class="keyword">if</span> (cachedAdvisors != <span class="literal">null</span>) &#123;</span><br><span class="line">advisors.addAll(cachedAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">MetadataAwareAspectInstanceFactory factory = <span class="keyword">this</span>.aspectFactoryCache.<span class="keyword">get</span>(aspectName);</span><br><span class="line">advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中对增强advice的获取委托给了<code>this.advisorFactory.getAdvisors(factory)</code>方法，此方法代码如下：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Advisor&gt; get<span class="constructor">Advisors(MetadataAwareAspectInstanceFactory <span class="params">maaif</span>)</span> &#123;</span><br><span class="line"><span class="comment">//获取标记为AspectJ的类</span></span><br><span class="line">final Class&lt;?&gt; aspectClass = maaif.get<span class="constructor">AspectMetadata()</span>.get<span class="constructor">AspectClass()</span>;</span><br><span class="line"><span class="comment">//获取标记为AspectJ的name</span></span><br><span class="line">final String aspectName = maaif.get<span class="constructor">AspectMetadata()</span>.get<span class="constructor">AspectName()</span>;</span><br><span class="line"><span class="comment">//校验是否符合aop注解规则</span></span><br><span class="line">validate(aspectClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span></span><br><span class="line"><span class="comment">// so that it will only instantiate once.</span></span><br><span class="line">final MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line"><span class="keyword">new</span> <span class="constructor">LazySingletonAspectInstanceFactoryDecorator(<span class="params">maaif</span>)</span>;</span><br><span class="line"></span><br><span class="line">final List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;<span class="literal">()</span>;</span><br><span class="line"><span class="comment">//获取实现Advisor类的所有标识没有Pointcut的方法。</span></span><br><span class="line">for (Method <span class="keyword">method</span> : get<span class="constructor">AdvisorMethods(<span class="params">aspectClass</span>)</span>) &#123;</span><br><span class="line"><span class="comment">//获取普通的增强器</span></span><br><span class="line">Advisor advisor = get<span class="constructor">Advisor(<span class="params">method</span>, <span class="params">lazySingletonAspectInstanceFactory</span>, <span class="params">advisors</span>.<span class="params">size</span>()</span>, aspectName);</span><br><span class="line"><span class="keyword">if</span> (advisor != null) &#123;</span><br><span class="line">advisors.add(advisor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If it's a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class="line"><span class="keyword">if</span> (!advisors.is<span class="constructor">Empty()</span><span class="operator"> &amp;&amp; </span>lazySingletonAspectInstanceFactory.get<span class="constructor">AspectMetadata()</span>.is<span class="constructor">LazilyInstantiated()</span>) &#123;</span><br><span class="line"><span class="comment">//如果寻找的增强器不为空而且又配置了增强延迟初始化那么需要在首位加入同步实例化增强器</span></span><br><span class="line">Advisor instantiationAdvisor = <span class="keyword">new</span> <span class="constructor">SyntheticInstantiationAdvisor(<span class="params">lazySingletonAspectInstanceFactory</span>)</span>;</span><br><span class="line">advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find introduction fields.</span></span><br><span class="line"><span class="comment">//获取DeclareParents 注解</span></span><br><span class="line">for (Field field : aspectClass.get<span class="constructor">DeclaredFields()</span>) &#123;</span><br><span class="line">Advisor advisor = get<span class="constructor">DeclareParentsAdvisor(<span class="params">field</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (advisor != null) &#123;</span><br><span class="line">advisors.add(advisor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此方法的逻辑是</p><ol><li>完成对增强器的获取，包括获取注解以及根据注解生成增强的步骤。</li><li>如果配置中将增强配置了延迟初始化，那么在首位加入同步实例化增强器保证增强使用之前的实例化</li><li>对DeclareParents注解的获取。</li></ol><p>下面详细讲解每个步骤<br><strong>普通增强器获取</strong><br>普通增强器的获取是通过<code>Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</code>代码获取<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Advisor getAdvisor(<span class="function"><span class="keyword">Method</span> <span class="title">candidateAdviceMethod</span>, <span class="title">MetadataAwareAspectInstanceFactory</span> <span class="title">aif</span>,</span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="title">declarationOrderInAspect</span>, <span class="title">String</span> <span class="title">aspectName</span>) <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        //校验</span></span></span><br><span class="line"><span class="function"><span class="comment">validate(aif.getAspectMetadata().getAspectClass());</span></span></span><br><span class="line"><span class="function"><span class="comment">        //切点信息获取</span></span></span><br><span class="line"><span class="function"><span class="comment">AspectJExpressionPointcut ajexp =</span></span></span><br><span class="line"><span class="function"><span class="comment">getPointcut(candidateAdviceMethod, aif.getAspectMetadata().getAspectClass());</span></span></span><br><span class="line"><span class="function"><span class="comment">if (ajexp == null) &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">return null;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function">//根据切点信息生成对应的增强器</span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="title">new</span> <span class="title">InstantiationModelAwarePointcutAdvisorImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">this, ajexp, aif, candidateAdviceMethod, declarationOrderInAspect, aspectName)</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(1)切点信息获取<br>切点信息获取就是指定注解的表达式信息获取，如<code>@Before(&quot;test&quot;)</code><br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AspectJExpressionPointcut get<span class="constructor">Pointcut(Method <span class="params">candidateAdviceMethod</span>, Class&lt;?&gt; <span class="params">candidateAspectClass</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//获取方法上注解</span></span><br><span class="line">AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">AbstractAspectJAdvisorFactory</span>.</span></span>find<span class="constructor">AspectJAnnotationOnMethod(<span class="params">candidateAdviceMethod</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (aspectJAnnotation<span class="operator"> == </span>null) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//使用AspectJExpressionPointcut 实例封装获取的信息</span></span><br><span class="line">AspectJExpressionPointcut ajexp =</span><br><span class="line"><span class="keyword">new</span> <span class="constructor">AspectJExpressionPointcut(<span class="params">candidateAspectClass</span>, <span class="params">new</span> String[0], <span class="params">new</span> Class[0])</span>;</span><br><span class="line"><span class="comment">//提取得到的注解中的表达式如:    //@Pointcut("execution(*  *.* test* (..))")中的execution( *  * .* test* (..))</span></span><br><span class="line">ajexp.set<span class="constructor">Expression(<span class="params">aspectJAnnotation</span>.<span class="params">getPointcutExpression</span>()</span>);</span><br><span class="line">return ajexp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected static AspectJAnnotation find<span class="constructor">AspectJAnnotationOnMethod(Method <span class="params">method</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//设置敏感的注解类</span></span><br><span class="line">Class&lt;? extends Annotation&gt;<span class="literal">[]</span> classesToLookFor = <span class="keyword">new</span> Class<span class="literal">[]</span> &#123;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Before</span>.</span></span><span class="keyword">class</span>, <span class="module-access"><span class="module"><span class="identifier">Around</span>.</span></span><span class="keyword">class</span>, <span class="module-access"><span class="module"><span class="identifier">After</span>.</span></span><span class="keyword">class</span>, <span class="module-access"><span class="module"><span class="identifier">AfterReturning</span>.</span></span><span class="keyword">class</span>, <span class="module-access"><span class="module"><span class="identifier">AfterThrowing</span>.</span></span><span class="keyword">class</span>, <span class="module-access"><span class="module"><span class="identifier">Pointcut</span>.</span></span><span class="keyword">class</span>&#125;;</span><br><span class="line">for (Class&lt;? extends Annotation&gt; c : classesToLookFor) &#123;</span><br><span class="line">AspectJAnnotation foundAnnotation = find<span class="constructor">Annotation(<span class="params">method</span>, <span class="params">c</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (foundAnnotation != null) &#123;</span><br><span class="line">return foundAnnotation;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定方法上的注解并使用AspectJAnnotation封装</span></span><br><span class="line"><span class="keyword">private</span> static &lt;A extends Annotation&gt; AspectJAnnotation&lt;A&gt; find<span class="constructor">Annotation(Method <span class="params">method</span>, Class&lt;A&gt; <span class="params">toLookFor</span>)</span> &#123;</span><br><span class="line">A result = <span class="module-access"><span class="module"><span class="identifier">AnnotationUtils</span>.</span></span>find<span class="constructor">Annotation(<span class="params">method</span>, <span class="params">toLookFor</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (result != null) &#123;</span><br><span class="line">return <span class="keyword">new</span> AspectJAnnotation&lt;A&gt;(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2)根据切点信息生成增强。所有的增强都由Advisor的实现类InstantiationModelAwarePointcutAdvisorImpl统一封装的。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InstantiationModelAwarePointcutAdvisorImpl(AspectJAdvisorFactory af, AspectJExpressionPointcut ajexp,</span><br><span class="line">MetadataAwareAspectInstanceFactory aif, Method method, int declarationOrderInAspect, String aspectName) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.declaredPointcut = ajexp;</span><br><span class="line"><span class="keyword">this</span>.method = method;</span><br><span class="line"><span class="keyword">this</span>.atAspectJAdvisorFactory = af;</span><br><span class="line"><span class="keyword">this</span>.aspectInstanceFactory = aif;</span><br><span class="line"><span class="keyword">this</span>.declarationOrder = declarationOrderInAspect;</span><br><span class="line"><span class="keyword">this</span>.aspectName = aspectName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (aif.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line"><span class="comment">// Static part of the pointcut is a lazy type.</span></span><br><span class="line">Pointcut preInstantiationPointcut =</span><br><span class="line">Pointcuts.union(aif.getAspectMetadata().getPerClausePointcut(), <span class="keyword">this</span>.declaredPointcut);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make it dynamic: must mutate from pre-instantiation to post-instantiation state.</span></span><br><span class="line"><span class="comment">// If it's not a dynamic pointcut, it may be optimized out</span></span><br><span class="line"><span class="comment">// by the Spring AOP infrastructure after the first evaluation.</span></span><br><span class="line"><span class="keyword">this</span>.pointcut = new PerTargetInstantiationModelPointcut(<span class="keyword">this</span>.declaredPointcut, preInstantiationPointcut, aif);</span><br><span class="line"><span class="keyword">this</span>.lazy = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// A singleton aspect.</span></span><br><span class="line"><span class="keyword">this</span>.instantiatedAdvice = instantiateAdvice(<span class="keyword">this</span>.declaredPointcut);</span><br><span class="line"><span class="keyword">this</span>.pointcut = declaredPointcut;</span><br><span class="line"><span class="keyword">this</span>.lazy = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在封装过程中只是简单地将信息封装在类的实例中，所有的信息单纯地赋值，在实例初始化的过程中还完成了对于增强器的初始化。因为不同的增强所体现的逻辑是不同的，比如@Be-fore（“test()”）与@After（“test()”）标签的不同就是增强器增强的位置不同，所以就需要不同的增强器来完成不同的逻辑，而根据注解中的信息初始化对应的增强器就是在instantiateAdvice函数中实现的。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function">Advice <span class="title">instantiateAdvice</span><span class="params">(AspectJExpressionPointcut pcut)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.atAspectJAdvisorFactory.getAdvice(</span><br><span class="line"><span class="keyword">this</span>.method, pcut, <span class="keyword">this</span>.aspectInstanceFactory, <span class="keyword">this</span>.declarationOrder, <span class="keyword">this</span>.aspectName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut ajexp,</span><br><span class="line">MetadataAwareAspectInstanceFactory aif, <span class="keyword">int</span> declarationOrderInAspect, String aspectName) &#123;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; candidateAspectClass = aif.getAspectMetadata().getAspectClass();</span><br><span class="line">validate(candidateAspectClass);</span><br><span class="line"></span><br><span class="line">AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line"><span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we get here, we know we have an AspectJ method.</span></span><br><span class="line"><span class="comment">// Check that it's an AspectJ-annotated class</span></span><br><span class="line"><span class="keyword">if</span> (!isAspect(candidateAspectClass)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Advice must be declared inside an aspect type: "</span> +</span><br><span class="line"><span class="string">"Offending method '"</span> + candidateAdviceMethod + <span class="string">"' in class ["</span> +</span><br><span class="line">candidateAspectClass.getName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Found AspectJ method: "</span> + candidateAdviceMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractAspectJAdvice springAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (aspectJAnnotation.getAnnotationType()) &#123;</span><br><span class="line"><span class="keyword">case</span> AtBefore:</span><br><span class="line">springAdvice = <span class="keyword">new</span> AspectJMethodBeforeAdvice(candidateAdviceMethod, ajexp, aif);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AtAfter:</span><br><span class="line">springAdvice = <span class="keyword">new</span> AspectJAfterAdvice(candidateAdviceMethod, ajexp, aif);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AtAfterReturning:</span><br><span class="line">springAdvice = <span class="keyword">new</span> AspectJAfterReturningAdvice(candidateAdviceMethod, ajexp, aif);</span><br><span class="line">AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.<span class="keyword">returning</span>())) &#123;</span><br><span class="line">springAdvice.setReturningName(afterReturningAnnotation.<span class="keyword">returning</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AtAfterThrowing:</span><br><span class="line">springAdvice = <span class="keyword">new</span> AspectJAfterThrowingAdvice(candidateAdviceMethod, ajexp, aif);</span><br><span class="line">AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.<span class="keyword">throwing</span>())) &#123;</span><br><span class="line">springAdvice.setThrowingName(afterThrowingAnnotation.<span class="keyword">throwing</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AtAround:</span><br><span class="line">springAdvice = <span class="keyword">new</span> AspectJAroundAdvice(candidateAdviceMethod, ajexp, aif);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AtPointcut:</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Processing pointcut '"</span> + candidateAdviceMethod.getName() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line"><span class="string">"Unsupported advice type on method "</span> + candidateAdviceMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now to configure the advice...</span></span><br><span class="line">springAdvice.setAspectName(aspectName);</span><br><span class="line">springAdvice.setDeclarationOrder(declarationOrderInAspect);</span><br><span class="line">String[] argNames = <span class="keyword">this</span>.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);</span><br><span class="line"><span class="keyword">if</span> (argNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">springAdvice.setArgumentNamesFromStringArray(argNames);</span><br><span class="line">&#125;</span><br><span class="line">springAdvice.calculateArgumentBindings();</span><br><span class="line"><span class="keyword">return</span> springAdvice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从函数中可以看到，Spring会根据不同的注解生成不同的增强器，例如AtBefore会对应AspectJMethodBeforeAdvice，而在AspectJMethodBeforeAdvice中完成了增强方法的逻辑。具体的实现感兴趣的读者可以自己看看。</p><p><strong>寻找匹配的增强器</strong><br>前面的函数中已经完成了所有增强器的解析，但是对于所有增强器来讲，并不一定都适用于当前的Bean，还要挑取出适合的增强器，也就是满足我们配置的通配符的增强器。具体实现在AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply中。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">List</span>&lt;Advisor&gt; findAdvisorsThatCanApply(</span><br><span class="line"><span class="keyword">List</span>&lt;Advisor&gt; candidateAdvisors, <span class="class"><span class="keyword">Class</span> <span class="title">beanClass</span>, <span class="title">String</span> <span class="title">beanName</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//过滤已经得到的advisors</span></span><br><span class="line"><span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续看findAdvisorsThatCanApply：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">List</span>&lt;Advisor&gt; findAdvisorsThatCanApply(<span class="keyword">List</span>&lt;Advisor&gt; candidateAdvisors, <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">clazz</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">List</span>&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line"><span class="comment">//首先处理引介增强</span></span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"> <span class="comment">//引介增强已经处理</span></span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line"><span class="comment">// already processed</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//对于普通bean 的处理</span></span><br><span class="line"><span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>findAdvisorsThatCanApply函数的主要功能是寻找所有增强器中适用于当前class的增强器。引介增强与普通的增强是处理不一样的，所以分开处理。而对于真正的匹配在canApply中实现。实现的逻辑很简单就是循环之前查找出来的所有增强，逐个判断该增强是否匹配当前的Bean，匹配则加进Advisor结果集的list中。</p><h3 id="2-1-3-创建代理"><a href="#2-1-3-创建代理" class="headerlink" title="2.1.3 创建代理"></a>2.1.3 创建代理</h3><p>上面的代码已经将获取的增强器讲完了，那么接下来便是根据增强器对匹配的bean创建代理了。我们是否忘了从哪里分析了，那再回顾下，从AbstractAutoProxyCreator.wrapIfNecessary方法分析开始，先是获取匹配的增强器调用getAdvicesAndAdvisorsForBean方法。然后再是创建代理createProxy方法，接下来我们将会分析此方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object createProxy(</span><br><span class="line">Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">ProxyFactory proxyFactory = new ProxyFactory();</span><br><span class="line"><span class="comment">// Copy our properties (proxyTargetClass etc) inherited from ProxyConfig.</span></span><br><span class="line"><span class="comment">//获取当前类中相关属性</span></span><br><span class="line">proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//决定对于给定的bean 是否应该使用targetClass 而不是他的接口代理,    </span></span><br><span class="line">        <span class="comment">//检查proxyTargeClass 设置以及preserveTargetClass 属性</span></span><br><span class="line"><span class="keyword">if</span> (!shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line"><span class="comment">// Must allow for introductions; can't just set interfaces to</span></span><br><span class="line"><span class="comment">// the target's interfaces only.</span></span><br><span class="line">Class&lt;?&gt;[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, <span class="keyword">this</span>.proxyClassLoader);</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; targetInterface : targetInterfaces) &#123;</span><br><span class="line"> <span class="comment">//添加代理接口</span></span><br><span class="line">proxyFactory.addInterface(targetInterface);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line"><span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line"><span class="comment">//设置要代理的类</span></span><br><span class="line">proxyFactory.addAdvisor(advisor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置要代理的类</span></span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br><span class="line"><span class="comment">//定制代理</span></span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来控制代理工厂被配置之后，是否还允许修改通知。    //缺省值为false （即在代理被配置之后，不允许修改代理的配置）。</span></span><br><span class="line">proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line"><span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">proxyFactory.setPreFiltered(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> proxyFactory.getProxy(<span class="keyword">this</span>.proxyClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于代理类的创建及处理，Spring委托给力ProxyFactory去处理，而在此函数中主要是对ProxyFactory的初始化操作，进而对真正的创建代理做准备，这些初始化内容包括：</p><ol><li>获取当前类中的属性</li><li>添加代理接口</li><li>封装Advisor并加入到ProxyFactory中。</li><li>设置要代理的类。</li><li>Spring还未子类提供了定制的方法customizeProxyFactory，子类可以在此方法中进行对ProxyFactory的进一步封装。</li><li>进行获取代理操作。</li></ol><p>其中封装Advisor并加入到ProxyFactory中以及创建代理是两个相对繁琐的过程，可以通过ProxyFactory提供的addAdvisor方法直接将增强器织入代理创建工厂中，但是将拦截器封装为增强器还是需要一定逻辑的，代码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine the advisors for the given bean, including the specific interceptors</span></span><br><span class="line"><span class="comment"> * as well as the common interceptor, all adapted to the Advisor interface.</span></span><br><span class="line"><span class="comment"> * @param beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * @param specificInterceptors the set of interceptors that is</span></span><br><span class="line"><span class="comment"> * specific to this bean (may be empty, but not null)</span></span><br><span class="line"><span class="comment"> * @return the list of Advisors for the given bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Advisor[] buildAdvisors(<span class="keyword">String</span> beanName, <span class="keyword">Object</span>[] specificInterceptors) &#123;</span><br><span class="line"><span class="comment">// 解析注册的所有InterceptorName</span></span><br><span class="line">Advisor[] commonInterceptors = resolveInterceptorNames();</span><br><span class="line"></span><br><span class="line">List&lt;<span class="keyword">Object</span>&gt; allInterceptors = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">Object</span>&gt;();</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//加入拦截器</span></span><br><span class="line">allInterceptors.addAll(Arrays.asList(specificInterceptors));</span><br><span class="line"><span class="keyword">if</span> (commonInterceptors != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.applyCommonInterceptorsFirst) &#123;</span><br><span class="line">allInterceptors.addAll(<span class="number">0</span>, Arrays.asList(commonInterceptors));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">allInterceptors.addAll(Arrays.asList(commonInterceptors));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="built_in">int</span> nrOfCommonInterceptors = (commonInterceptors != <span class="keyword">null</span> ? commonInterceptors.length : <span class="number">0</span>);</span><br><span class="line"><span class="built_in">int</span> nrOfSpecificInterceptors = (specificInterceptors != <span class="keyword">null</span> ? specificInterceptors.length : <span class="number">0</span>);</span><br><span class="line">logger.debug(<span class="string">"Creating implicit proxy for bean '"</span> + beanName + <span class="string">"' with "</span> + nrOfCommonInterceptors +</span><br><span class="line"><span class="string">" common interceptors and "</span> + nrOfSpecificInterceptors + <span class="string">" specific interceptors"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Advisor[] advisors = <span class="keyword">new</span> Advisor[allInterceptors.<span class="built_in">size</span>()];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; allInterceptors.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="comment">//将拦截器转换为advisor</span></span><br><span class="line">advisors[i] = <span class="keyword">this</span>.advisorAdapterRegistry.wrap(allInterceptors.<span class="built_in">get</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Advisor wrap(<span class="keyword">Object</span> adviceObject) <span class="keyword">throws</span> UnknownAdviceTypeException &#123;</span><br><span class="line"><span class="comment">//如果本身就是Advisor类型，无需处理直接转换</span></span><br><span class="line"><span class="keyword">if</span> (adviceObject <span class="keyword">instanceof</span> Advisor) &#123;</span><br><span class="line"><span class="keyword">return</span> (Advisor) adviceObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为此封装方法只对Advisor于advice两种类型的数据有效，如果不是将不能封装。</span></span><br><span class="line"><span class="keyword">if</span> (!(adviceObject <span class="keyword">instanceof</span> Advice)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(adviceObject);</span><br><span class="line">&#125;</span><br><span class="line">Advice advice = (Advice) adviceObject;</span><br><span class="line"><span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line"><span class="comment">// So well-known it doesn't even need an adapter.</span></span><br><span class="line"><span class="comment">//如果是MethodInterceptor类型则使用DefaultPointcutAdvisor封装。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (AdvisorAdapter adapter : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line"><span class="comment">// Check that it is supported.</span></span><br><span class="line"><span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultPointcutAdvisor(advice);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于Spring中涉及过多的拦截器、增强器、增强方法等方式来对逻辑进行增强，所以非常有必要统一封装成Advisor来进行代理的创建，完成了增强的封装过程，那么解析最重要的一步就是代理的创建于获取了。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object get<span class="constructor">Proxy(ClassLoader <span class="params">classLoader</span>)</span> &#123;</span><br><span class="line">return create<span class="constructor">AopProxy()</span>.get<span class="constructor">Proxy(<span class="params">classLoader</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>创建代理</strong><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> synchronized AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">activate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建代理</span></span><br><span class="line"><span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport <span class="built_in">config</span>)</span> throws AopConfigException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">config</span>.isOptimize() || <span class="built_in">config</span>.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(<span class="built_in">config</span>)) &#123;</span><br><span class="line">Class targetClass = <span class="built_in">config</span>.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == null) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line"><span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(<span class="built_in">config</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CglibProxyFactory.createCglibProxy(<span class="built_in">config</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(<span class="built_in">config</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此已经完成了代理的创建，我们可以看到Spring会动态的选择使用Cglib或者jdk创建代理。这里就不细分析了。<br>至此我们分析完了<code>&lt;aop:aspectj-autoproxy/&gt;</code>标签创建Spring的AOP全流程。</p><h2 id="2-2-lt-aop-config-gt-使用分析"><a href="#2-2-lt-aop-config-gt-使用分析" class="headerlink" title="2.2 &lt;aop:config&gt;使用分析"></a>2.2 &lt;aop:config&gt;使用分析</h2><p>前面分析完了在使用<code>&lt;aop:aspectj-autoproxy/&gt;</code>标签时，aop的实现原理，接着分析<code>&lt;aop:config&gt;</code>实现原理。<br><code>&lt;aop:config&gt;</code>在 1.2节中解析此标签时我们看到注册了<code>AspectJAwareAdvisorAutoProxyCreator</code>看到此类是不是很熟悉，看下此类的集成关系图：<br><img src="http://imgcdn.yalongkeji.com/aop.png" alt="aop"><br>看到了吧，我们使用注解aop的<code>AnnotationAwareAspectJAutoProxyCreator</code>就是直接继承此类的，回头看看2.1节的<code>AnnotationAwareAspectJAutoProxyCreator</code>此类继承关系图。如果你理解了之前对注解AOP实现原理的分析，那么相信你对此标签的实现原理也是了然于胸了。这里主要说下步骤，就不进行相信分析了</p><ol><li>解析<code>&lt;aop:config&gt;</code>标签时，获取对应的子标签，注册对应的Bean，例如Advisor和pointcut。</li><li>程序运行调用getbean获取bean时执行<code>AnnotationAwareAspectJAutoProxyCreator</code>的<code>postProcessBeforeInstantiation</code>方法进行代理的创建。<code>postProcessBeforeInstantiation</code>方法我们在之前就分析了此流程。</li></ol><blockquote><p>至此aop的流程就分析完了，感兴趣的可以留言探讨，一起学习进步。</p></blockquote><blockquote><p>想了解更多技术文章信息，请继续关注<a href="http://wiliam.me">wiliam.s Blog</a>，谢谢，欢迎来访！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;http://imgcdn.yalongkeji.com/timg.jpg&quot;/&gt;
    
    </summary>
    
      <category term="houduan" scheme="http://wiliam.me/categories/houduan/"/>
    
      <category term="spring" scheme="http://wiliam.me/categories/houduan/spring/"/>
    
    
      <category term="spring" scheme="http://wiliam.me/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring中环境架构的解析说明</title>
    <link href="http://wiliam.me/2017/02/26/20170226091750.html"/>
    <id>http://wiliam.me/2017/02/26/20170226091750.html</id>
    <published>2017-02-26T01:17:50.000Z</published>
    <updated>2022-02-03T12:48:45.461Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Spring在3.1版本添加了org.springframework.core.env包，该包下面描述了Spring的环境架构体系，对Spring环境配置方面起到了重要作用。该包下面有PropertyResolver，Environment等接口描述Spring的环境信息。其中Environment接口作用可以让Spring根据不同的环境配置加载不同的配置信息。例如我们常用的测试环境和生产环境需要使用不同的数据源，通过配置环境信息即可达到无缝切换。PropertyResolver可以让我们加载属性信息。接下来就详细解说Spring的环境架构</p></blockquote><a id="more"></a><h1 id="1-环境架构整体说明"><a href="#1-环境架构整体说明" class="headerlink" title="1.环境架构整体说明"></a>1.环境架构整体说明</h1><h2 id="1-1-重要接口和类"><a href="#1-1-重要接口和类" class="headerlink" title="1.1.重要接口和类"></a>1.1.重要接口和类</h2><h3 id="1-1-1-PropertySource类"><a href="#1-1-1-PropertySource类" class="headerlink" title="1.1.1.PropertySource类"></a>1.1.1.PropertySource类</h3><p>PropertySource是抽象类，该类是对(name/value)属性的抽象，其中value可以是任何类型属性，例如可以是java.util.Properties对象，java.util.Map对象，ServletContext和ServletConfig对象(可以获取初始化参数)。其方法<code>public abstract Object getProperty(String name)</code>是抽象方法，由不同的子类去实现。Spring对常用的属性都定义了对应的实现类，不同的实现代表了不同的类型属性。其类图如下：<br><img src="http://imgcdn.yalongkeji.com/blog/20170225/113634020.jpg" alt="propertysource"><br>上图其中最重要的是EnumerablePropertySource类，是枚举行属性类，该类下面的子类就有我们常用属性文件对象，如PropertiesPropertySource<br>PropertySource和Spring中的Resource接口很像，Resource对所有的资源文件进行了抽象，并提供了各种资源的实现类，如ClassPathResource，FileSystemResource等，这里就不详细介绍，感兴趣的可以自己去探索。</p><h3 id="1-1-2-PropertyResolver接口"><a href="#1-1-2-PropertyResolver接口" class="headerlink" title="1.1.2.PropertyResolver接口"></a>1.1.2.PropertyResolver接口</h3><p>PropertyResolver接口中定义了属性资源解析方法，可以理解为对PropertySource类的属性value解析。</p><h3 id="1-1-3-Environment接口"><a href="#1-1-3-Environment接口" class="headerlink" title="1.1.3.Environment接口"></a>1.1.3.Environment接口</h3><p>Environment接口继承PropertyResolver接口，之所以要单独列出来是因为Spring对外暴露的是Environment而不是PropertyResolver接口。类图如下：<br><img src="http://imgcdn.yalongkeji.com/blog/20170225/120820499.jpg" alt="environment"></p><p>从图中可以看出两大实体组件，分别是环境（StandardEnvironment）和属性解决器（PropertySourcesPropertyResolver）。spring框架把两个组件的对外提供的功能性接口和自身的配置性接口进行了拆分，组件的配置API都集中在ConfigurableXXX接口中。</p><p>两个组件都只有唯一的标准实现类，即StandardEnvironment和PropertySourcesPropertyResolver。</p><p>两个组件之间的关系可以这样理解：</p><p>环境对象通过持有属性解决器对象的引用，从而实现组件复用。同时，环境对象所定义的接口继承自属性解决器接口，因此，环境对象也具有属性解决器的所有功能，而且在属性解决器的功能基础之上，又扩展出了环境的功能。细心的读者可能已经看出，这实际上是使用了装饰器模式，StandardEnvironment通过对PropertySourcesPropertyResolver的装饰，进行了功能增强。</p><p>我们可以将整个体系拆分成Environment和PropertyResolver两个体系，然后分别讲解</p><p><div></div></p><p><div style="display:inline;float:left;"><img src="http://imgcdn.yalongkeji.com/blog/20170225/122833815.jpg" width="300" height="400"></div></p><p><div style="display:inline;"><img src="http://imgcdn.yalongkeji.com/blog/20170225/122913758.jpg" width="300" height="400"> </div></p><div><ol><li><p><a href="http://wiliam.me/2017/02/25/20170225125742.html">PropertyResolver属性解析器</a></p></li><li><p><a href="http://wiliam.me/2017/02/25/20170225125823.html">Environment应用上下文环境</a></p></li></ol><h1 id="2-Environment使用"><a href="#2-Environment使用" class="headerlink" title="2.Environment使用"></a>2.Environment使用</h1><p>通过第一节的介绍说明了Spring整体环境架构，那么整体环境架构已经构建好了，我们该如何使用呢？<br>Spring提供了EnvironmentCapable接口，我们实现该接口可以使组件具有环境。接口定义如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>EnvironmentCapable &#123;</span><br><span class="line"></span><br><span class="line">Environment getEnvironment();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口定义的唯一方法，就是获取与当前组件相关联的Environment环境对象。<br>该接口的实现类如图：<br>![EnvironmentCapable实现类][5]</p><p>可以看到ApplicationContext接口继承自这个接口，也就是说所有应用上下文都是具有环境的，当使用ApplicationContext实现类时调用getEnvironment就可以获取环境信息了。</p><hr><p>参考资料<br><a href="https://my.oschina.net/lixin91/blog/672351" target="_blank" rel="noopener">spring-core组件详解——环境体系</a><br><a href="http://www.jianshu.com/p/948c303b2253" target="_blank" rel="noopener">详解Spring中的Profile</a></p><blockquote><p>想了解更多技术文章信息，请继续关注<a href="http://wiliam.me">wiliam.s Blog</a>，谢谢，欢迎来访！</p></blockquote></div>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;http://imgcdn.yalongkeji.com/blog/20170226/151236696.jpg&quot;/&gt;
    
    </summary>
    
      <category term="houduan" scheme="http://wiliam.me/categories/houduan/"/>
    
      <category term="spring" scheme="http://wiliam.me/categories/houduan/spring/"/>
    
    
      <category term="spring" scheme="http://wiliam.me/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring的Environment应用上下文环境</title>
    <link href="http://wiliam.me/2017/02/25/20170225125823.html"/>
    <id>http://wiliam.me/2017/02/25/20170225125823.html</id>
    <published>2017-02-25T04:58:23.000Z</published>
    <updated>2022-02-03T12:48:45.462Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Spring使用Environment表示应用的上下文环境，Environment接口作用可以让Spring根据不同的环境配置加载不同的配置信息。例如我们常用的测试环境和生产环境需要使用不同的数据源，通过配置环境信息即可达到无缝切换。</p></blockquote><a id="more"></a><h1 id="1-整体介绍"><a href="#1-整体介绍" class="headerlink" title="1.整体介绍"></a>1.整体介绍</h1><p>Environment环境代表当前应用运行时所处的环境。</p><p>整个应用环境模型包括2个关键方面：</p><h2 id="1-1-profiles配置组（以下简称组）："><a href="#1-1-profiles配置组（以下简称组）：" class="headerlink" title="1.1. profiles配置组（以下简称组）："></a>1.1. profiles配置组（以下简称组）：</h2><p>一个profile组，是一个以name名称命名的、逻辑上的、要被注册到容器中的BeanDefinition的集合。简单一点说，一个profile就代表一组BeanDefinition，当是xml配置时使用<beans profile>。当加载解析xml配置文件的时候，只有active=true激活的BeanDefinition才会被加载进容器。当是注解使用@Profile配置。下面举例说明</beans></p><h3 id="1-1-1-xml配置"><a href="#1-1-1-xml配置" class="headerlink" title="1.1.1. xml配置"></a>1.1.1. xml配置</h3><p>ServerEnv接口<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package me.wiliam.spring.xmlconfig.bean;</span><br><span class="line"></span><br><span class="line">public<span class="built_in"> interface </span>ServerEnv &#123;</span><br><span class="line"></span><br><span class="line">void getEnvData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生产环境实现类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.wiliam.spring.xmlconfig.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductEnv</span> <span class="keyword">implements</span> <span class="title">ServerEnv</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEnvData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"this is product Environment"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试环境实现类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.wiliam.spring.xmlconfig.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEnv</span> <span class="keyword">implements</span> <span class="title">ServerEnv</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEnvData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"this is Test Environment"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>xml配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"product"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serverEnv"</span> <span class="attr">class</span>=<span class="string">"me.wiliam.spring.xmlconfig.bean.ProductEnv"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"test"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serverEnv"</span> <span class="attr">class</span>=<span class="string">"me.wiliam.spring.xmlconfig.bean.TestEnv"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>测试类<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package me.wiliam.spring.xmlconfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> me.wiliam.spring.xmlconfig.bean.ServerEnv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppMain</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"me/wiliam/spring/xmlconfig/config/spring-profile.xml"</span>);</span><br><span class="line">ServerEnv serverEnv = (ServerEnv)context.getBean(<span class="string">"serverEnv"</span>);</span><br><span class="line">serverEnv.getEnvData();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>jvm环境变量设置<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-Dspring.profiles.active</span>=product</span><br></pre></td></tr></table></figure></p><p>执行结果<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> product Environment</span><br></pre></td></tr></table></figure></p><h3 id="1-1-2-注解配置"><a href="#1-1-2-注解配置" class="headerlink" title="1.1.2. 注解配置"></a>1.1.2. 注解配置</h3><p>ProdcutConfig配置类<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@Profile</span>(<span class="string">"product"</span>)</span><br><span class="line">public class ProdcutConfig &#123;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Bean</span>(name=<span class="string">"serverEnv"</span>)</span><br><span class="line">public ProductEnv productEnv()&#123;</span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">ProductEnv</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TestConfig配置类<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@Profile</span>(<span class="string">"test"</span>)</span><br><span class="line">public class TestConfig &#123;</span><br><span class="line"><span class="variable">@Bean</span>(name=<span class="string">"serverEnv"</span>)</span><br><span class="line">public TestEnv testEnv()&#123;</span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">TestEnv</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总配置<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@Import</span>(&#123;TestConfig.class,ProdcutConfig.class&#125;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APP</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">ServerEnv server =context.getBean(ServerEnv<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">server.getEnvData();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>jvm环境变量设置<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-Dspring.profiles.active</span>=product</span><br></pre></td></tr></table></figure></p><p>执行结果<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> <span class="keyword">is</span> product Environment</span><br></pre></td></tr></table></figure></p><h3 id="1-1-3-配置说明总结"><a href="#1-1-3-配置说明总结" class="headerlink" title="1.1.3.配置说明总结"></a>1.1.3.配置说明总结</h3><p>上面切换配置使用的是jvm环境变量配置的，如果是web环境，可以针对测试环境和生产环境在启动时增加环境变量就可以自动区分生产环境还是测试环境了。<br>激活profile还有其他几种方式，例如使用xml，下面说明下：</p><p>Spring通过两个不同属性来决定哪些profile可以被激活(注意：profile是可以同时激活多个的),一个属性是spring.profiles.active和spring.profiles.default。这两个常量值在Spring的AbstractEnvironment中有定义，查看AbstractEnvironment源码：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> ACTIVE_PROFILES_PROPERTY_NAME = <span class="string">"spring.profiles.active"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> DEFAULT_PROFILES_PROPERTY_NAME = <span class="string">"spring.profiles.default"</span>;</span><br></pre></td></tr></table></figure></p><p>如果当spring.profiles.active属性被设置时，那么Spring会优先使用该属性对应值来激活Profile。当spring.profiles.active没有被设置时，那么Spring会根据spring.profiles.default属性的对应值来进行Profile进行激活。如果上面的两个属性都没有被设置，那么就不会有任务Profile被激活，只有定义在Profile之外的Bean才会被创建。我们发现这两个属性值其实是Spring容器中定义的属性，而我们在实际的开发中很少会直接操作Spring容器本身，所以如果要设置这两个属性，其实是需要定义在特殊的位置，让Spring容器自动去这些位置读取然后自动设置,这些位置主要为如下定义的地方：</p><ul><li>作为SpringMVC中的DispatcherServlet的初始化参数</li><li>作为Web 应用上下文中的初始化参数</li><li>作为JNDI的入口</li><li>作为环境变量</li><li>作为虚拟机的系统参数</li><li>使用@AtivceProfile来进行激活:单测使用</li></ul><p>上面的前三个Springwebmvc使用的是StandardServletEnvironment其继承StandardEnvironment，初始化时会读取ServletContext和ServletConfig的InitParameter这时就会将我们在配置文件中配置的spring.profiles.active配置项读入spring的上下文中了，然后spring就能根据配置的环境信息加载对应的配置项了。</p><p>我们在实际的使用过程中，可以定义默认的profile为开发环境，当实际部署的时候，主需要在实际部署的环境服务器中将spring.profiles.active定义在环境变量中来让Spring自动读取当前环境下的配置信息，这样就可以很好的避免不同环境而频繁修改配置文件的麻烦。</p><h2 id="1-2-properties环境变量："><a href="#1-2-properties环境变量：" class="headerlink" title="1.2.properties环境变量："></a>1.2.properties环境变量：</h2><p>在几乎所有的应用中，Properties环境变量都扮演着非常重要的角色，且这些变量值可以来自于各种PropertySource属性源，如：properties文件、jvm虚拟机环境变量、操作系统环境变量、JNDI、Servlet上下文参数、自定义的属性对象、Map对象，等等。Environment环境对象为用户提供了方便的接口，用于配置和使用属性源。</p><p>整体类图如下：<br>![environment][1]</p><p>刚才提到环境模型具有2个关键方面：profiles和properties，从体系图中可以看出，properties方面的所有功能由PropertyResolver属性解决器来实现，环境模型只是通过装饰模式，在PropertyResolver功能的基础上，额外扩展出了profiles方面的功能。因此在接口方面，Environment继承自PropertyResolver，从实现类方面，AbstractEnvironment类内部持有一个PropertySourcesPropertyResolver类型对象的引用，PropertyResolver和ConfigurablePropertyResolver的接口，都委托调用了PropertySourcesPropertyResolver实现。</p><h1 id="2-接口说明"><a href="#2-接口说明" class="headerlink" title="2.接口说明"></a>2.接口说明</h1><p>关于PropertyResolver，我前边的文章<a href="http://wiliam.me/2017/02/25/20170225125742.html">PropertyResolver属性解析器</a>已经进行了详细的解释，因此在本文中，我们重点关注环境模型在profiles方面的实现原理，体系图如下：<br><img src="http://imgcdn.yalongkeji.com/blog/20170225/122833815.jpg" width="300" height="400" alt="singleEnvironment"></p><h2 id="2-1-Environment接口："><a href="#2-1-Environment接口：" class="headerlink" title="2.1.Environment接口："></a>2.1.Environment接口：</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">interface</span> <span class="title">Environment</span> <span class="keyword">extends</span> <span class="title">PropertyResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>获取当前环境对象激活的所有profile组。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@return</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code"> */</span></span></span></span><br><span class="line"><span class="built_in">String</span>[] getActiveProfiles();</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>获取默认的profile组。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>如果当前环境对象中激活的组为空（getActiveProfiles()返回空数组）的话，</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>则会启用默认profile组。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@return</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code"> */</span></span></span></span><br><span class="line"><span class="built_in">String</span>[] getDefaultProfiles();</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>判断给定的一个或多个组中，是否存在满足当前环境对象配置的组（任意一个组满足即可）。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>如：</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>调用acceptsProfiles("p1","!p2")，如果当前环境对象激活了p1，</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>或者没有激活p2（注意是或，满足一个条件即可），则返回true，否则返回false。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param profiles</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@return</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code"> */</span></span></span></span><br><span class="line">boolean acceptsProfiles(<span class="built_in">String</span>... profiles);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-ConfigurableEnvironment："><a href="#2-2-ConfigurableEnvironment：" class="headerlink" title="2.2.ConfigurableEnvironment："></a>2.2.ConfigurableEnvironment：</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableEnvironment</span> <span class="keyword">extends</span> <span class="title">Environment</span>, <span class="title">ConfigurablePropertyResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>重新设置激活的组集合。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param profiles</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code"> */</span></span></span></span><br><span class="line"><span class="keyword">void</span> setActiveProfiles(<span class="built_in">String</span>... profiles);</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>向当前激活的组集合中添加一个组。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param profile</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code"> */</span></span></span></span><br><span class="line"><span class="keyword">void</span> addActiveProfile(<span class="built_in">String</span> profile);</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>设置默认激活的组集合。激活的组集合为空时会使用默认的组集合。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param profiles</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code"> */</span></span></span></span><br><span class="line"><span class="keyword">void</span> setDefaultProfiles(<span class="built_in">String</span>... profiles);</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>获取当前环境对象中的属性源集合，也就是应用环境变量。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>属性源集合其实就是一个容纳PropertySource的容器。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>这个方法提供了直接配置属性源的入口。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@return</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code"> */</span></span></span></span><br><span class="line">MutablePropertySources getPropertySources();</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>获取操作系统环境变量</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>这个方法提供了直接配置系统环境变量的入口。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@return</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code"> */</span></span></span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; getSystemEnvironment();</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>获取虚拟机环境变量</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>这个方法提供了直接配置虚拟机环境变量的入口。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@return</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code"> */</span></span></span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; getSystemProperties();</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>合并指定环境对象中的配置到当前环境对象中。</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@param parent</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code"> */</span></span></span></span><br><span class="line"><span class="keyword">void</span> merge(ConfigurableEnvironment parent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-AbstractEnvironment抽象基类："><a href="#2-3-AbstractEnvironment抽象基类：" class="headerlink" title="2.3.AbstractEnvironment抽象基类："></a>2.3.AbstractEnvironment抽象基类：</h2><p>该类实际上实现了以上接口的所有方法，且额外扩展了自定义属性源的入口：<br>        protected void customizePropertySources(MutablePropertySources propertySources);<br>但是因为初始时属性源集合只是一个空集合，没有任何意义，因为该类定义为抽象基类，不能直接实例化使用。部分代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部分代码</span></span><br><span class="line"><span class="comment"> * @author lixin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEnvironment</span> &#123;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可变属性源集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MutablePropertySources propertySources = <span class="keyword">new</span> MutablePropertySources();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在构造方法中直接调用自定义属性源集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">customizePropertySources(<span class="keyword">this</span>.propertySources);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义属性源集合，</span></span><br><span class="line"><span class="comment"> * 默认空实现，子类可重写，用来配置属性源。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param propertySources</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizePropertySources</span><span class="params">(MutablePropertySources propertySources)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-4-StandardEnvironment："><a href="#2-4-StandardEnvironment：" class="headerlink" title="2.4.StandardEnvironment："></a>2.4.StandardEnvironment：</h2><p>该类定义了Spring应用运行时使用的标准环境，其实就是重写了customizePropertySources方法，先后追加了jvm虚拟机环境变量属性源和操作系统环境变量属性源这两个属性源。当然对于特殊的spring运行环境，我们可以创建标准环境的子类，以实现属性源的扩充，比如：StandardServletEnvironment类，用于web应用环境。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StandardEnvironment</span> <span class="keyword">extends</span> <span class="title">AbstractEnvironment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作系统环境变量属性源的名称</span></span><br><span class="line">public static <span class="keyword">final</span> <span class="type">String</span> <span class="type">SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME</span> = <span class="string">"systemEnvironment"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jvm虚拟机系统环境变量属性源的名称</span></span><br><span class="line">public static <span class="keyword">final</span> <span class="type">String</span> <span class="type">SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME</span> = <span class="string">"systemProperties"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> void customizePropertySources(<span class="type">MutablePropertySources</span> propertySources) &#123;</span><br><span class="line"><span class="comment">// 追加虚拟机环境变量属性源</span></span><br><span class="line">propertySources.addLast(<span class="keyword">new</span> <span class="type">MapPropertySource</span>(<span class="type">SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME</span>, getSystemProperties()));</span><br><span class="line"><span class="comment">// 追加操作系统环境变量属性源</span></span><br><span class="line">propertySources.addLast(<span class="keyword">new</span> <span class="type">SystemEnvironmentPropertySource</span>(<span class="type">SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME</span>, getSystemEnvironment()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就是spring框架的基本环境体系。<br>[1]:<a href="http://imgcdn.yalongkeji.com/blog/20170225/120820499.jpg" target="_blank" rel="noopener">http://imgcdn.yalongkeji.com/blog/20170225/120820499.jpg</a><br>[2]:<a href="http://imgcdn.yalongkeji.com/blog/20170225/122833815.jpg" target="_blank" rel="noopener">http://imgcdn.yalongkeji.com/blog/20170225/122833815.jpg</a></p><blockquote><p>想了解更多技术文章信息，请继续关注<a href="http://wiliam.me">wiliam.s Blog</a>，谢谢，欢迎来访！</p></blockquote>]]></content>
    
    <summary type="html">
    
      Spring使用Environment表示应用的上下文环境，Environment接口作用可以让Spring根据不同的环境配置加载不同的配置信息。例如我们常用的测试环境和生产环境需要使用不同的数据源，通过配置环境信息即可达到无缝切换
    
    </summary>
    
      <category term="houduan" scheme="http://wiliam.me/categories/houduan/"/>
    
      <category term="spring" scheme="http://wiliam.me/categories/houduan/spring/"/>
    
    
      <category term="spring" scheme="http://wiliam.me/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring的PropertyResolver属性解析器</title>
    <link href="http://wiliam.me/2017/02/25/20170225125742.html"/>
    <id>http://wiliam.me/2017/02/25/20170225125742.html</id>
    <published>2017-02-25T04:57:42.000Z</published>
    <updated>2022-02-03T12:48:45.463Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对Spring的PropertyResolver属性解析器详细介绍。</p></blockquote><a id="more"></a><h1 id="1-整体介绍"><a href="#1-整体介绍" class="headerlink" title="1.整体介绍"></a>1.整体介绍</h1><p>PropertyResolver属性解析器，主要具有两个功能：</p><ol><li><p>通过propertyName属性名获取与之对应的propertValue属性值（getProperty）。</p></li><li><p>把${propertyName:defaultValue}格式的属性占位符，替换为实际的值(resolvePlaceholders)。</p></li></ol><p><strong>注意：</strong>getProperty获取的属性值，全都是调用resolvePlaceholders进行占位符替换后的值。</p><p>组件体系图如下：<br><img src="http://imgcdn.yalongkeji.com/blog/20170225/122913758.jpg" width="300" height="400" alt="singleEnvironment"></p><h1 id="2-接口介绍"><a href="#2-接口介绍" class="headerlink" title="2.接口介绍"></a>2.接口介绍</h1><h2 id="2-1-PropertyResolver接口："><a href="#2-1-PropertyResolver接口：" class="headerlink" title="2.1.PropertyResolver接口："></a>2.1.PropertyResolver接口：</h2><p>该接口定义了组件所具有的所有功能。其一是通过key获取对应的value，当获取不到value时，有3种选择：返回null值、使用指定的默认值或者抛出一个非法状态异常。获取到的value值默认是String类型，当然也可以认为指定一种类型，这依赖于ConversionService进行类型转换。<br>另外还有一个问题：属性值中可以包含${}格式的占位符，因此，接口添加了另一个功能就是替换属性值中的占位符（注意：属性名是不允许存在占位符的，就算存在，组件也不会当作占位符进行替换）。当占位符无法替换时，也有2种选择：保持原样或者抛出一个非法参数异常。具体接口如下：<br><img src="http://static.oschina.net/uploads/space/2016/0505/153950_RyJe_2624635.png" alt="PropertyResolver类"></p><h2 id="2-2-ConfigurablePropertyResolver接口："><a href="#2-2-ConfigurablePropertyResolver接口：" class="headerlink" title="2.2.ConfigurablePropertyResolver接口："></a>2.2.ConfigurablePropertyResolver接口：</h2><p>该接口定义了如何对组件本身进行配置。如：刚刚提到获取value时可以指定任意类型，这依赖于ConversionService进行类型转换，当前接口就提供了对ConversionService的设置和获取。另外，可以配置属性占位符的格式，包括：占位符前缀（默认为”${“）、占位符后缀（默认为”}”）、占位符值分隔符（默认为”:”，用于分隔propertyName和defaultValue）。组件还可以设置哪些属性是必须存在的，还可以校验必须存在的属性是否真的存在（不存在的话会抛出异常）。具体接口如下：<br><img src="http://static.oschina.net/uploads/space/2016/0505/155208_UULx_2624635.png" alt="ConfigurablePropertyResolver接口"></p><h2 id="2-3-AbstractPropertyResolver类："><a href="#2-3-AbstractPropertyResolver类：" class="headerlink" title="2.3.AbstractPropertyResolver类："></a>2.3.AbstractPropertyResolver类：</h2><p>上述两个接口的抽象实现类。它实现了ConfigurablePropertyResolver接口的所有方法。关于PropertyResolver接口方法，还有3个getProperty方法需要子类实现（其他重载方法均调用这3个方法）：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> getProperty(<span class="built_in">String</span> <span class="keyword">key</span>);</span><br><span class="line">&lt;T&gt; T getProperty(<span class="built_in">String</span> <span class="keyword">key</span>, <span class="keyword">Class</span>&lt;T&gt; targetType);</span><br><span class="line">&lt;T&gt; <span class="keyword">Class</span>&lt;T&gt; getPropertyAsClass(<span class="built_in">String</span> <span class="keyword">key</span>, <span class="keyword">Class</span>&lt;T&gt; targetType);</span><br><span class="line">/**</span><br><span class="line">* 当前类还额外定义了一个抽象方法，用于直接返回获取到的value值（不进行占位符替换）。</span><br><span class="line">* 一般的getProperty方法默认都会替换掉value值中的占位符后返回。</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">protected</span> abstract <span class="built_in">String</span> getPropertyAsRawString(<span class="built_in">String</span> <span class="keyword">key</span>);</span><br></pre></td></tr></table></figure></p><p>至于替换属性占位符，则借助2个PropertyPlaceholderHelper属性占位符助手（工具类）对象完成，这2个对象一个为严格模式，一个为非严格模式。</p><h2 id="2-4-PropertySourcesPropertyResolver类："><a href="#2-4-PropertySourcesPropertyResolver类：" class="headerlink" title="2.4.PropertySourcesPropertyResolver类："></a>2.4.PropertySourcesPropertyResolver类：</h2><p>该类是体系中唯一的完整实现类。它以PropertySources属性源集合（内部持有属性源列表List<propertysource>）为属性值的来源，按序遍历每个PropertySource，获取到一个非null的属性值则返回。</propertysource></p><blockquote><p>想了解更多技术文章信息，请继续关注<a href="http://wiliam.me">wiliam.s Blog</a>，谢谢，欢迎来访！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对Spring的PropertyResolver属性解析器详细介绍。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="houduan" scheme="http://wiliam.me/categories/houduan/"/>
    
      <category term="spring" scheme="http://wiliam.me/categories/houduan/spring/"/>
    
    
      <category term="spring" scheme="http://wiliam.me/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客next主题添加Fork me on GitHub</title>
    <link href="http://wiliam.me/2017/02/11/20170211185643.html"/>
    <id>http://wiliam.me/2017/02/11/20170211185643.html</id>
    <published>2017-02-11T10:56:43.000Z</published>
    <updated>2022-02-03T12:48:45.459Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在网上浏览博客时经常看到页面的右上角或左上角有一个fork me on github的按钮，本文将介绍如何实现。</p></blockquote><a id="more"></a><h1 id="1、效果展示"><a href="#1、效果展示" class="headerlink" title="1、效果展示"></a>1、效果展示</h1><p>右上角截图<br><img src="http://imgcdn.yalongkeji.com/blog/20170211/175902504.png" alt="right"><br>左上角截图<br><img src="http://imgcdn.yalongkeji.com/blog/20170211/180101588.png" alt="left"></p><h1 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h1><h2 id="2-1、样式挑选"><a href="#2-1、样式挑选" class="headerlink" title="2.1、样式挑选"></a>2.1、样式挑选</h2><p><a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener">点我跳转</a>  挑选你自己喜欢的样式。</p><h2 id="2-2、next主题实现"><a href="#2-2、next主题实现" class="headerlink" title="2.2、next主题实现"></a>2.2、next主题实现</h2><p>打开文件：<code>hexo博客根目录\themes\next\layout\_layout.swig</code> 找到如下代码块<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; container_class &#125;&#125;</span><span class="xml"><span class="tag"><span class="string"> </span></span></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_class %&#125;</span><span class="xml"><span class="tag"><span class="string"></span></span></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"><span class="tag"><span class="string"> "</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"headband"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>添加自己喜欢的样式后结果如下<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; container_class &#125;&#125;</span><span class="xml"><span class="tag"><span class="string"> </span></span></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_class %&#125;</span><span class="xml"><span class="tag"><span class="string"></span></span></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"><span class="tag"><span class="string"> "</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"headband"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"https://github.com/wiliam2015"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"position: absolute; top: 0; right: 0; border: 0;"</span> <span class="attr">src</span>=<span class="string">"https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67"</span> <span class="attr">alt</span>=<span class="string">"Fork me on GitHub"</span> <span class="attr">data-canonical-src</span>=<span class="string">"https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>访问你的本地服务测试看看修改的效果吧。</p><h2 id="2-3、小屏幕不显示fork-me-on-github"><a href="#2-3、小屏幕不显示fork-me-on-github" class="headerlink" title="2.3、小屏幕不显示fork me on github"></a>2.3、小屏幕不显示fork me on github</h2><p>按照上面的步骤当屏幕缩小后还会显示fork me on github图标，但这不是我想要的，我希望在大屏下显示，小屏后就不显示了。方法如下：<br>修改文件<code>hexo博客根目录\themes\next\layout\_layout.swig</code>  找到如下代码块<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">class</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; html_class | lower &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> '_partials/head.swig' %&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>添加如下代码，结果如下<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> '_partials/head.swig' %&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml">  .forkme&#123;</span></span><br><span class="line"><span class="xml">display: none;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">  @media (min-width: 768px) &#123;</span></span><br><span class="line"><span class="xml">.forkme&#123;</span></span><br><span class="line"><span class="xml">display: inline;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>最后在2.2节添加的代码块上套上div加上class就行了，如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"forkme"</span>&gt;</span><br><span class="line">&lt;a target=<span class="string">"_blank"</span> href=<span class="string">"https://github.com/wiliam2015"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"position: absolute; top: 0; right: 0; border: 0;"</span> <span class="attr">src</span>=<span class="string">"https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67"</span> <span class="attr">alt</span>=<span class="string">"Fork me on GitHub"</span> <span class="attr">data-canonical-src</span>=<span class="string">"https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p><p>最后在试试效果达到自己的想要的了</p><blockquote><p>想了解更多技术文章信息，请继续关注<a href="http://wiliam.me">wiliam.s Blog</a>，谢谢，欢迎来访！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;http://imgcdn.yalongkeji.com/blog/20170226/131154979.png&quot;/&gt;
    
    </summary>
    
      <category term="tool" scheme="http://wiliam.me/categories/tool/"/>
    
      <category term="hexo" scheme="http://wiliam.me/categories/tool/hexo/"/>
    
    
      <category term="hexo" scheme="http://wiliam.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>终于等到你&lt;br/&gt;&lt;small style=&#39;font-size:12px;color:gray;&#39;&gt;————爸爸妈妈的小棉袄&lt;/small&gt;</title>
    <link href="http://wiliam.me/2017/02/11/20170211171202.html"/>
    <id>http://wiliam.me/2017/02/11/20170211171202.html</id>
    <published>2017-02-11T09:12:02.000Z</published>
    <updated>2022-02-03T12:48:45.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017年2月1日我和老婆的爱情结晶来到了这个世界，嘿嘿，我的贴心小棉袄，从此自己就当爸爸了。</p></blockquote><a id="more"></a><h1 id="终于等到你"><a href="#终于等到你" class="headerlink" title="终于等到你"></a>终于等到你</h1><p>宝宝你可知道，妈妈为了让你来到这个世界，可是受尽了辛苦，从最初有了你的时候爸爸和妈妈高兴的都睡不着觉到每次孕检时的担心，生怕医生说出有不好结果。在你还在妈妈肚肚的时候，妈妈贫血又缺钙等，为了你的好好的成长妈妈可是吃了很多药和食物进补哦，还有就是妈妈有甲减症状，需要每天都吃药维持指标正常，这些都是为了宝宝你的健康成长。最后都到了40周了，妈妈的羊水都偏少了，宝宝你还是没有动静，爸爸妈妈也是很着急也很担心，你的爷爷奶奶，姥姥姥爷，大姑，大姨等都是很担心，最后胎心监测你的心跳加速了，频率都达到170了，医生说是宫内窘迫，最后不得不进行剖宫产手术让你来到这个世界。最后终于等到你，来到了这个世界和爸爸妈妈见面了，我们一起组成了三口之家，希望宝宝你能好好的体验这个五彩缤纷的世界。</p><h1 id="希望"><a href="#希望" class="headerlink" title="希望"></a>希望</h1><p>宝宝为了让你能够健康快乐的成长，爸爸妈妈会努力给你一个健康快乐的成长环境。最后希望宝宝以后健康快乐的成长，踏踏实实做人，活出自己的精彩人生。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017年2月1日我和老婆的爱情结晶来到了这个世界，嘿嘿，我的贴心小棉袄，从此自己就当爸爸了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="zatan" scheme="http://wiliam.me/categories/zatan/"/>
    
      <category term="杂谈" scheme="http://wiliam.me/categories/zatan/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
</feed>
